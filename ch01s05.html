<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>1.5. A programkód formális modellje</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Szoftvertesztelés"><link rel="up" href="ch01.html" title="1. fejezet - A tesztelés alapfogalmai"><link rel="prev" href="ch01s04.html" title="1.4. A tesztelési tevékenység"><link rel="next" href="ch02.html" title="2. fejezet - A tesztelés helye a szoftver életciklusában"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1.5. 
      
            A programkód formális modellje</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s04.html">El&#337;z&#337;</a>&nbsp;</td><th width="60%" align="center">1. fejezet - A tesztelés alapfogalmai</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02.html">Következ&#337;</a></td></tr></table><hr></div><div class="sect1" title="1.5. A programkód formális modellje"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e313"></a>1.5. 
      
            <a name="_Toc291178530"></a>A programkód formális modellje</h2></div></div></div><p>Számos tesztelési módszer a program forráskódjának elemzésén alapul. Ez az alpont a vonatkozó legfontosabb alapismereteket foglalja össze.</p><p>A programozási nyelvek egyik fontos jellemz&#337;je a szigorú szerkezet, a viszonylag egyszer&#369;bb strukturáltság. Mindkét jellemz&#337; abból fakad, hogy olyan nyelvet lehet automatikus feldolgozásra, értelmezésre kiválasztani, amely</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>hatékonyan feldolgozható egy automatával;</p></li><li class="listitem"><p>elegend&#337; kifejez&#337; ereje van az algoritmusok leírására.</p></li></ol></div><p>A programnyelvek egy mesterséges nyelvnek tekinthet&#337;k, melyek teljesítik a fenti feltételeket. A programozási nyelvek elméleti hátterét a formális nyelvek területe fedi le.</p><div class="sect2" title="1.5.1. A forráskód szintaktikai ellen&#337;rzése"><div class="titlepage"><div><div><h3 class="title"><a name="d0e331"></a>1.5.1. 
      
               <a name="_Toc291178531"></a>A forráskód szintaktikai ellen&#337;rzése</h3></div></div></div><p>Az formális nyelvek mondatok szavakból, jelekb&#337;l történ&#337; felépítését írják le. Formálisan a formális nyelv egy párossal írható le, melyben adott az alapjelek halmaza és a képezhet&#337;, elfogadott mondatok halmaza. A mondatok halmaza az összes képezhet&#337; véges jelsorozatok halmazának részhalmazaként értelmezhet&#337;.</p><div class="mediaobject" align="center"><img src="images/kep16.png" align="middle"></div><p>A nyelvek esetében egy nyelvtan írja le a jelhalmazból képzett és a nyelv által elfogadott mondatok halmazát. A nyelvtan leírja a mondatok képzési szabályait. A szabályok alapvet&#337;en</p><div class="mediaobject" align="center"><img src="images/kep17.png" align="middle"></div><p>alakúak, ahol a szimbólumok mondat egységeket jelölnek. A szimbólumok vonatkozásában megkülönböztetünk </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>atomi szimbólumokat (ezek a jelek, a  szigma halmaz elemei)</p></li><li class="listitem"><p>összetett szimbólumokat (nagyobb egységeket fog össze)</p></li></ol></div><p></p><p>A nyelvtan formális alakja az alábbi kifejezéssel adható meg</p><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; G = (T, N, R, S)</p><p></p><p>ahol </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>T : atomi, terminális szimbólumok halmaza</p></li><li class="listitem"><p>N: összetett szimbólumok halmaza</p></li><li class="listitem"><p>R: szabályok halmaza</p></li><li class="listitem"><p>S: mondat szimbólum, mely az N eleme.</p></li></ol></div><p>Az egyes nyelvtanok lényegesen különbözhetnek egymástól a szabályok összetettségét tekintve. A formális nyelvek nyelvtanának legismertebb osztályozási rendszere a Chomsky kategorizálás. A Chomsky hierarchia négy nyelvtan osztályt különböztet meg: </p><p>&nbsp;</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>reguláris nyelvek: a szabályok <img src="images/kep23.png"> alakúak;</p></li><li class="listitem"><p>környezet függ&#337; nyelvek: &nbsp;a szabályok <img src="images/kep24.png"> alakúak;</p></li><li class="listitem"><p>környezet függ&#337; nyelvek: a szabályok <img src="images/kep25.png"> alakúak;</p></li><li class="listitem"><p>általános nyelvek: nincs megkötés a szabályokra.</p></li></ol></div><p>A kifejezésekben a kisbet&#369;s elemek atomi szimbólumot, a nagybet&#369;s elemek összetett szimbólumokat jelölnek. Az X egy tetsz&#337;leges szimbólum. </p><p>A programozási nyelvek alapvet&#337;en a reguláris nyelvek osztályába tartoznak. Egy SQL DELETE &nbsp;parancs esetében például az alábbi szabályokat kell alkalmazni, ahol a példában egy &#8211;egy szót is atomi szimbólumnak tekintünk.</p><p></p><p>&nbsp; &nbsp; &nbsp; &nbsp; S = delete R</p><p>&nbsp; &nbsp; &nbsp; &nbsp; R = from Q</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Q = ?tabla P</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Q = ?tabla</p><p>&nbsp; &nbsp; &nbsp; &nbsp; P = where O</p><p>&nbsp; &nbsp; &nbsp; &nbsp; O = ?feltétel</p><p></p><p>A mintában a ? jel mögött egy újabb egység van, melyhez önálló saját értelmezési nyelvtan tartozik.</p><p>A nyelvtan alapján egy bejöv&#337; mondathoz meghatározható, hogy illeszkedik-e a megadott nyelvtanra vagy sem. A reguláris nyelvtanok esetében az ellen&#337;rzés egyik lehetséges eszköze egy FSA automata alkalmazása.</p><p>A véges automaták olyan rendszert jelentenek, mely tartalmaz</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>állapot elemeket (az elemzés egyes fázisait szimbolizálják)</p></li><li class="listitem"><p>állapot átmeneteket</p></li><li class="listitem"><p>eseményeket</p></li></ol></div><p></p><p>Az események az egyes állapot átmenetekhez köthet&#337;k. Az automata m&#369;ködési elve az alábbi alapelemeken nyugszik:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>induláskor egy induló állapotban van a rendszer</p></li><li class="listitem"><p>egy esemény bekövetkezésekor állapot átmenet valósul meg: az aktuális állapotból azon átmeneten megy tovább, melyhez a bejöv&#337; esemény tartozik</p></li><li class="listitem"><p>az automata egy végállapot elérésekor áll le</p></li></ol></div><p></p><p>A szintaktika ellen&#337;rzéskor a végállapot lehet egy elfogadó vagy egy elvet&#337; (hiba) állapot.</p><p>Az automaták a m&#369;ködés jellege szerint több csoportba kategorizálhatjuk, f&#337; típusai:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>véges automata</p></li><li class="listitem"><p>determinisztikus automata</p></li><li class="listitem"><p>fuzzy automata</p></li></ol></div><p>Az el&#337;z&#337;ekben ismertetett reguláris nyelvek megvalósíthatók véges automatákkal így az értelmezés folyamata egy automatával végrehajtható. Az automata m&#369;ködési modellje egy táblázattal foglalható össze, &nbsp;melyben az alábbi oszlopok szerepelnek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>induló állapot</p></li><li class="listitem"><p>esemény</p></li><li class="listitem"><p>célállapot</p></li></ol></div><p></p><p>Az esemény a forráskód elemzésénél a soron következ&#337; beolvasott jelet (szót) jelöli. A DELETE parancs esetében az alábbi táblázat alapján m&#369;ködhet az értelmez&#337;:</p><div class="mediaobject" align="center"><img src="images/kep18.png" align="middle"></div><p>A táblázatban * jel jelöli az egyéb eseményeket és # jel a mondat vége eseménynek felel meg.</p><p></p></div><div class="sect2" title="1.5.2. Forráskód szemantikai ellen&#337;rzése"><div class="titlepage"><div><div><h3 class="title"><a name="d0e483"></a>1.5.2. 
      
               <a name="_Toc291178532"></a>Forráskód szemantikai ellen&#337;rzése</h3></div></div></div><p>A szintaktikai elemzés azt vizsgálja, hogy a kód, mint mondatok sorozata érvényes-e, megfelel-e a nyelvtan szabályainak. A nyelvtanilag érvényes mondatsor azonban nem biztos, hogy az elvárt tartalmú tevékenységet végzi el. Emiatt a szintaktikai helyesség nem garantálja a tartalmi, szemantikai helyességet. </p><p>A szemantikai helyesség ellen&#337;rzése sokkal összetettebb feladat, mint a szintaktika ellen&#337;rzése, hiszen nem áll rendelkezésre olyan szemantikai nyelvtan, amellyel össze lehetne vetni a leírt kódot. A kód ugyan karaktersorozatnak fele meg a forrásállományban, de a tartalom szempontjából más egységek strukturálható. A kód szokásos reprezentációs alakjai:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>szavak sorozata (szintaktikai ellen&#337;rzéshez), </p></li><li class="listitem"><p>utasítások hierarchiája,</p></li><li class="listitem"><p>végrehajtási gráf.</p></li><li class="listitem"><p></p></li></ol></div><p>A hierarchia reprezentáció arra utal, hogy a szavakból rendszerint egy nagyobb utasítás egység áll össze, és az utasítások legtöbbször egymásba ágyazhatók. A fontosabb algoritmus szerkezeti elemek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>modul (rutin)</p></li><li class="listitem"><p>szekvencia</p></li><li class="listitem"><p>elágazás</p></li><li class="listitem"><p>ciklus</p></li></ol></div><p></p><p>A hierarchikus szerkezetet jelzi, hogy egy elágazás tartalmazhat</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>szekvenciát,</p></li><li class="listitem"><p>elágazást,</p></li><li class="listitem"><p>ciklust.</p></li></ol></div><p>Tehát a program algoritmusa strukturálisan rekurzív felépítés&#369;. A algoritmus megadása mellet a program másik f&#337; egysége az adatstruktúra leírása. Az adatstruktúra esetében is ez hierarchikus szerkezettel találkozhatunk. A f&#337;bb adattárolási egységek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>skalár</p></li><li class="listitem"><p>tömb</p></li><li class="listitem"><p>halmaz</p></li><li class="listitem"><p>rekord</p></li><li class="listitem"><p>fa</p></li></ol></div><p>Itt is igaz, hogy egyes egységek más adatelemeket magukba foglalhatnak. </p><p>A hierarchia reprezentáció a program statikus szerkezeté írja le, a program azonban egy végrehajtási szerkezet ad meg. &nbsp;A program hagyományos végrehajtása során mindig van egy kitüntetett utasítás, mely végrehajtás alatt áll. Ez az aktuális utasítás vándorol a program futása alatt. Egy adott utasításból egy vagy több más utasításba kerülhet át a vezérlés. </p><p>A végrehajtási gráf formalizmusban az egyes utasításokat mint csomópontokat vesszük, és a vezérlés átadásokat a gráf éleit szimbolizálják. A gráfban található egy jelöl&#337; elem, token, mely mutatja az aktuális utasítás helyét. A program futása jól nyomon követhet&#337; a gráfban a token mozgását követve. A gráf formalizmus tehát a program dinamikus jellegét mutatja. </p><p>A program helyességének biztosítása a szoftverfejlesztés egyik legfontosabb feladata. A tesztelés folyamata, mely során ellen&#337;rzésre kerül a program helyessége sokféleképpen értelmezhet&#337;. A tesztelést végezhet&#337; szisztematikus próbálkozásokkal is, de ha nem sikerül minden lehetséges esetet lefedni, akkor ez a módszer nem garantálhatja a program teljeskör&#369; helyességét. Csak olyam megoldás adhat biztonságot, amely bizonyíthatóan le tudja fedni a lehetséges eseteket. érezhet&#337;, ezen igényt csak egy matematikailag megalapozott módszer tudná biztosítani. érdekes kérdés, hogy van-e ilyen matematikai formalizmus és az vajon alkalmazható-e a gyakorlati méret&#369; feladatokban. A következ&#337; részben a tesztelés formális megközelítésének alapjait tekintjük át röviden.</p><p>A formális tesztelés elméleti alapjait Hoare fektette le 1969-ben, bevezetve az axiomatikus szemantika terület fogalmát, melynek célja a programok viselkedésének leírása és helyességük bizonyítása. </p><p>Az axiomatikus szemantika alapvet&#337;en a matematikai logika eszközrendszerére épül és egyik alapeleme a megkötés, assertion fogalma. &nbsp;Az assertion egy olyan állítás, predikátum, amelyet a programnak valamely pontjában teljesítenie kell. &nbsp;A modell további lényeges elemei az el&#337;feltételek (precondition) &nbsp;és az végfeltételek (postcondition). A módszer tehát nem önmagában vizsgálja a program helyességét, keretfeltételek mellett végzi az ellen&#337;rzést. Felteszi, hogy indulás el&#337;tt igaz a precondition és végén teljesülnie kell a postcondition megkötésnek. A program tehát egy </p><p>&nbsp; &nbsp; &nbsp; &nbsp; {P} s {Q}</p><p>hármassal adott, ahol</p><p>&nbsp; &nbsp; &nbsp; &nbsp; P : precondition</p><p>&nbsp; &nbsp; &nbsp; &nbsp; s : source (forráskód)</p><p>&nbsp; &nbsp; &nbsp; &nbsp; Q: postcondition.</p><p>Természetesen a P és Q részek lehetnek mindig teljesül&#337; kifejezések is. &nbsp;A Hoare formalizmus célja a program részleges helyességének ellen&#337;rzése, tehát annak bizonyítása, hogy ha P teljesül, akkor az s végrehajtása után Q is teljesülni fog.</p><p>A módszer a matematikai logika eszközrendszerére alapozva P-b&#337;l kiindulva az s elemeinek felhasználásával levezeti a Q helyességét. A levezetés logikában megszokott implikációs szabályokra épít, melyeket </p><div class="mediaobject" align="center"><img src="images/kep19.png" align="middle"></div><p>&nbsp;alakban lehet megadni és azt jelzi, hogy ha teljesülnek a &nbsp;p1,p2,p3 &#8230; logikai kifejezések, akkor a q állítás is teljesül. A levezetési szabályok egy s program esetén az alábbi típusokat fedik le:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>hozzárendelés (assignment rule)</p></li><li class="listitem"><p>szekvencia (sequence rule)</p></li><li class="listitem"><p>ugrás (skip rule)</p></li><li class="listitem"><p>feltételes elágazás (conditional rule)</p></li><li class="listitem"><p>ciklus (loop rule)</p></li></ol></div><p>Mivel a Q levezetése a P-b&#337;l több lépésen keresztül történhet csak, a bizonyítás egy levezetési fával írható le. </p><p>Példaként a feltételes utasításhoz tartozó szabályt véve, az implikáció a következ&#337; alakot ölti:</p><div class="mediaobject" align="center"><img src="images/kep20.png" align="middle"></div><p>A feldolgozás egy további eleme a feltételek er&#337;sítése vagy gyengítése. A precondition er&#337;sítése formalizmusa:</p><div class="mediaobject" align="center"><img src="images/kep21.png" align="middle"></div><p>Például ez alapján vezethet&#337; le az alábbi összefüggés:</p><div class="mediaobject" align="center"><img src="images/kep22.png" align="middle"></div><p>A fenti példákból is jól látható, hogy a Hoare formalizmus a helyesség ellen&#337;rzését<a name="_GoBack"></a> igen absztrakt szinten végzi és igen körülményes és költséges a levezetési fa felépítése. Emiatt a módszert napjainkban még csak kisebb méret&#369; feladatoknál alkalmazzák és a gyakorlati rendszerekben dönt&#337;en a heurisztikus módszerek dominálnak. </p><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s04.html">El&#337;z&#337;</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch01.html">Fel</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02.html">Következ&#337;</a></td></tr><tr><td width="40%" align="left" valign="top">1.4. 
      
            A tesztelési tevékenység&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Tartalom</a></td><td width="40%" align="right" valign="top">&nbsp;2. fejezet - A tesztelés helye a szoftver életciklusában</td></tr></table></div></body></html>