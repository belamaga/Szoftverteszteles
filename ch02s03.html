<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>2.3. M√≥dszertanok</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Szoftvertesztel√©s"><link rel="up" href="ch02.html" title="2. fejezet - A tesztel√©s helye a szoftver √©letciklus√°ban"><link rel="prev" href="ch02s02.html" title="2.2. A szoftver √©letciklusa"><link rel="next" href="ch03.html" title="3. fejezet - Statikus tesztel√©si technik√°k"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2.3. 
      
            M√≥dszertanok</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch02s02.html">El&#337;z&#337;</a>&nbsp;</td><th width="60%" align="center">2. fejezet - A tesztel√©s helye a szoftver √©letciklus√°ban</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch03.html">K√∂vetkez&#337;</a></td></tr></table><hr></div><div class="sect1" title="2.3. M√≥dszertanok"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e702"></a>2.3. 
      
            <a name="_Toc285293660"></a>M√≥dszertanok</h2></div></div></div><p>A m√≥dszertanok feladata, hogy meghat√°rozz√°k, hogy a szoftver √©letciklus egyes l√©p√©sei milyen sorrendben k√∂vetik egym√°st, milyen dokumentumokat, szoftver term√©keket kell el&#337;√°ll√≠tani √©s hogyan. Egy nagy szab√°lyk√∂nyvre eml√©keztetnek, ami pontosan le√≠rja, hogyan kell szoftvert &#8222;f&#337;zni&#8221;. Ha betartjuk a receptet, akkor egy √°tlagos min&#337;s√©g&#369; szoftvert kapunk, de az √°tlagos min&#337;s√©g garant√°lt.</p><p>A k√∂vetkez&#337;kben azokat a m√≥dszertanokat ismertetj√ºk, amelyek k√ºl√∂n√∂sen nagy hangs√∫lyt fektetnek a tesztel√©sre.</p><div class="sect2" title="2.3.1. V-modell"><div class="titlepage"><div><div><h3 class="title"><a name="d0e711"></a>2.3.1. 
      
               <a name="_Toc285293661"></a>V-modell</h3></div></div></div><p>A V-modell (angolul: V-Model vagy Vee Model) a nev√©t onnan kapta, hogy k√©t sz√°ra van √©s √≠gy egy V bet&#369;h√∂z hasonl√≠t. Az egyik sz√°ra megegyezik a v√≠zes√©s modellel. Ez a fejleszt√©si sz√°r. A m√°sik sz√°ra a l√©trej√∂v&#337; term√©kek tesztjeit tartalmazza. Ez a tesztel√©si sz√°r. Az egy szinten l√©v&#337; fejleszt√©si √©s tesztel√©si l√©p√©sek √∂sszetartoznak, azaz a tesztel√©si l√©p√©s a fejleszt√©si l√©p√©s sor√°n l√©trej√∂tt dokumentumokat haszn√°lja, vagy a l√©trej√∂tt term√©ket teszteli. Ennek megfelel&#337;en az el&#337;√≠rt fejleszt√©si √©s tesztel√©si l√©p√©sek a k√∂vetkez&#337;k:</p><p>
      
               <img src="images/kep2.png">
   
            </p><p>A V-modell a v√≠zes√©s modell kieg√©sz√≠t√©se tesztel√©ssel. Ez azt jelenti, hogy el&#337;sz√∂r v√©gre kell hajtani a fejleszt√©s l√©p√©seit, ezut√°n j√∂nnek a tesztel√©s l√©p√©sei. Ha valamelyik teszt hib√°t tal√°l, akkor vissza kell menni a megfelel&#337; fejleszt√©si l√©p√©sre.</p><p>A V-modell hasonl√≥an a v√≠zes√©s modellhez nagyon merev, de alkalmaz√≥i kev√©sb√© ragaszkodnak ehhez a merevs√©ghez, mint a v√≠zes√©s modell alkalmaz√≥i. Ennek megfelel&#337;en jobban elterjedt. F&#337; jellemz&#337;je a teszt k√∂zponti szerepe.</p><p>Egy tipikus V-modell v√°ltozatban el&#337;sz√∂r felm√©rj√ºk az ig√©nyeket √©s elk√©sz√≠tj√ºk a k√∂vetelm√©ny specifik√°ci√≥t. Ezt √ºzleti elemz&#337;k v√©gzik, akik a megrendel&#337; √©s a fejleszt&#337;k fej√©vel is k√©pesek gondolkozni. A k√∂vetelm√©ny specifik√°ci√≥ban j√≥l meghat√°rozott √°tv√©teli krit√©riumokat fogalmaznak meg, amik lehetnek funkcion√°lis √©s nemfunkcion√°lis ig√©nyek is. Ez lesz majd az alapja a felhaszn√°l√≥i √°tv√©teli tesztnek (User Acceptance Test, UAT). Mag√°t a k√∂vetelm√©ny specifik√°ci√≥t is tesztelik. A felhaszn√°l√≥k t√ºzetesen √°tn√©zik az √ºzleti elemz&#337;k seg√≠ts√©g√©vel, hogy t√©nylegesen minden ig√©ny√ºket lefedi-e a dokumentum. Ez l√©nyeges r√©sze a modellnek, mert a folyamatban visszafel√© haladni nem lehet, √©s ha rossz a k√∂vetelm√©ny specifik√°ci√≥, akkor nem az ig√©nyeknek megfelel&#337; szoftver fog elk√©sz√ºlni. Ezzel szemben p√©ld√°ul a protot√≠pus modellben lehet pongyola az ig√©nyfelm√©r√©s, mert az a protot√≠pusok sor√°n √∫gyis pontos√≠t√°sra ker√ºl.</p><p>Ezut√°n k√∂vetkezik a funkcion√°lis specifik√°ci√≥ elk√©sz√≠t√©se, amely le√≠rja, hogyan kell majd m&#369;k√∂dnie a szoftvernek. Ez lesz a rendszerteszt alapja. Ha a funkcion√°lis specifik√°ci√≥ azt √≠rja, hogy a &#8222;V√°s√°rol gomb megnyom√°s√°ra ki kell √≠rni a kos√°rban l√©v&#337; √°ruk √©rt√©k√©t&#8221;, akkor a rendszertesztben lesz egy vagy t√∂bb teszteset, amely ezt teszteli. P√©ld√°ul, ha √ºres a kos√°r, akkor az √°rnak null√°nak kell lennie.</p><p>Ezut√°n k√∂vetkezik a rendszerterv, amely le√≠rja, hogy az egyes funkci√≥kat hogyan, milyen komponensekkel, oszt√°lyokkal, met√≥dusokkal, adatb√°zissal fogjuk megval√≥s√≠tani. Ez lesz a komponens teszt egyik alapja. A rendszerterv le√≠rja tov√°bb, hogy a komponensek hogyan m&#369;k√∂dnek egy√ºtt. Ez lesz az integr√°ci√≥s teszt alapja.</p><p>Ezut√°n a rendszertervnek megfelel&#337;en k√∂vetkezik az implement√°ci√≥. Minden met√≥dushoz egy vagy t√∂bb unit-tesztet kell k√©sz√≠teni. Ezek alapja nem csak az implement√°ci√≥, hanem a rendszerterv is. A nagyobb egys√©geket, oszt√°lyokat, al- √©s f&#337;funkci√≥kat is komponens teszt al√° kell vetni az implement√°ci√≥ √©s a rendszerterv alapj√°n.</p><p>Ha ezen sikeresen t√∫l vagyunk, akkor az integr√°ci√≥s teszt k√∂vetkezik a rendszerterv alapj√°n. Ha itt probl√©m√°k mer√ºlnek fel, akkor visszamegy√ºnk a V bet&#369; m√°sik sz√°r√°ra a rendszertervhez. Megn√©zz√ºk, hogy a hiba a rendszertervben vagy az implement√°ci√≥ban van-e. Ha kell, megv√°ltoztatjuk a rendszertervet, majd az implement√°ci√≥t is.</p><p>Az integr√°ci√≥s teszt ut√°n j√∂n a rendszerteszt a funkcion√°lis specifik√°ci√≥ alapj√°n. Hasonl√≥an, hiba eset√©n a V bet&#369; m√°sik sz√°r√°ra megy√ºnk, azaz visszal√©p√ºnk a funkcion√°lis specifik√°ci√≥ elk√©sz√≠t√©s√©re. Majd j√∂n az √°tv√©teli teszt a k√∂vetelm√©ny specifik√°ci√≥ alapj√°n. Rem√©lhet&#337;leg itt m√°r nem lesz hiba, mert kezdhetn√©nk az eg√©szet el√∂lr&#337;l, ami egyenl&#337; a sikertelen projekttel.</p><p>Ha a fejleszt√©s √©s tesztel√©s alatt nem v√°ltoznak a k√∂vetelm√©nyek, akkor ez egy nagyon j√≥, kiforrott, t√°mogatott m√≥dszertan. Ha val√≥sz√≠n&#369; a k√∂vetelm√©nyek v√°ltoz√°sa, akkor ink√°bb iterat√≠v, vagy m√©g ink√°bb agilis m√≥dszert v√°lasszunk.</p></div><div class="sect2" title="2.3.2. Protot√≠pus modell"><div class="titlepage"><div><div><h3 class="title"><a name="d0e740"></a>2.3.2. 
      
               <a name="_Toc285293662"></a>Protot√≠pus modell</h3></div></div></div><p>A protot√≠pus modell v√°lasz a v√≠zes√©s modell sikertelens√©g√©re. A fejleszt&#337; c√©gek r√°j√∂ttek, hogy tarthatatlan a v√≠zes√©s modell megk√∂zel√≠t√©se, hogy a rendszerrel a felhaszn√°l√≥ csak a projekt v√©g√©n tal√°lkozik. Gyakran csak ekkor der√ºlt ki, hogy az √©letciklus elej√©n f√©lre√©rtett√©k egym√°st a felek √©s nem a val√≥s k√∂vetelm√©nyeknek megfelel&#337; rendszer sz√ºletett. Ezt elker√ºlend&#337; a protot√≠pus modell azt mondja, hogy a v√©gs&#337; √°tad√°s el&#337;tt t√∂bb protot√≠pust is sz√°ll√≠tsunk le, hogy mihamarabb kider√ºljenek a f√©lre√©rt√©sek, illetve a megrendel&#337; l√°ssa, mit v√°rhat a rendszert&#337;l.</p><p>A protot√≠pus alap√∫ megk√∂zel√≠t√©se a fejleszt√©snek azon alapszik, hogy a megrendel&#337; √ºzleti folyamatai, k√∂vetelm√©nyei nem ismerhet&#337;k meg teljesen. M√°r csak az√©rt sem, mert ezek az id&#337;vel v√°ltoznak (l√°sd az agilis m√≥dszertanokat). A k√∂vetelm√©nyeket √©rdemes finom√≠tani protot√≠pusok seg√≠ts√©g√©vel. Ha a felhaszn√°l√≥ haszn√°latba vesz egy protot√≠pust, akkor k√©pes megfogalmazni, hogy az mi√©rt nem felel meg az elv√°r√°sainak √©s hogyan kellene megv√°ltoztatni. Ebben a megk√∂zel√≠t√©sben a lesz√°ll√≠tott rendszer is egy protot√≠pus.</p><p>Ez a megk√∂zel√≠t√©s annyira sikeres volt, hogy a modern m√≥dszertanok majd mindegyike protot√≠pus alap√∫. Az iterat√≠v m√≥dszerek √°ltal√°ban minden m√©rf√∂ldk&#337;h√∂z k√∂tnek egy protot√≠pust. Az agilis m√≥dszertanok ak√°r minden nap √∫j (l√°sd napi ford√≠t√°s) protot√≠pust √°ll√≠tanak el&#337;.</p><p>A kezdeti protot√≠pus fejleszt√©se √°ltal√°ban a k√∂vetkez&#337; l√©p√©sekb&#337;l √°ll:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>1. l√©p√©s: Az alap k√∂vetelm√©nyek meghat√°roz√°sa: Olyan alap k√∂vetelm√©nyek meghat√°roz√°sa, mint a bemeneti √©s kimeneti adatok. √°ltal√°ban a teljes√≠tm√©nyre vagy a biztons√°gra vonatkoz√≥ k√∂vetelm√©nyekkel nem foglalkozunk.</p></li><li class="listitem"><p>2. l√©p√©s: Kezdeti protot√≠pus kifejleszt√©se: Csak a felhaszn√°l√≥i fel√ºleteket fejlesztj√ºk le egy erre alkalmas CASE eszk√∂zzel. A m√∂g√∂tte l√©v&#337; funkci√≥kat nem, kiv√©ve az √∫j ablakok nyit√°s√°t.</p></li><li class="listitem"><p>3. l√©p√©s: Bemutat√°s: Ez egyfajta felhaszn√°l√≥i √°tv√©teli teszt. A v√©gfelhaszn√°l√≥k megvizsg√°lj√°k a protot√≠pust, √©s jelzik, hogy mit gondolnak m√°sk√©nt, illetve mit tenn√©nek m√©g hozz√°.</p></li><li class="listitem"><p>4. l√©p√©s. A k√∂vetelm√©nyek pontos√≠t√°sa: A visszajelz√©seket felhaszn√°lva pontos√≠tjuk a k√∂vetelm√©ny specifik√°ci√≥t. Ha m√©g mindig nem el√©g pontos a specifik√°ci√≥, akkor a protot√≠pust tov√°bbfejlesztj√ºk √©s ugrunk a 3. l√©p√©sre. Ha el√©g pontos k√©pet kaptunk arr√≥l, hogy mit is akar a megrendel&#337;, akkor az egyes m√≥dszertanok m√°st √©s m√°st √≠rnak el&#337;.</p></li></ol></div><p>
      
               <img src="images/kep3.png">
   
            </p><p>A protot√≠pus k√©sz√≠t√©st akkor a legc√©lszer&#369;bb haszn√°lni, ha a rendszer √©s a felhaszn√°l√≥ k√∂z√∂tt sok lesz a p√°rbesz√©d. A modell on-line rendszerek elemz√©s√©ben √©s tervez√©s√©ben nagyon hat√©kony, k√ºl√∂n√∂sen a tranzakci√≥ feldolgoz√°sn√°l. Olyan rendszerekn√©l, ahol kev√©s interakci√≥ zajlik a rendszer √©s a felhaszn√°l√≥ k√∂z√∂tt, ott kev√©sb√© √©ri meg a protot√≠pus modell haszn√°lata, ilyenek p√©ld√°ul a sz√°m√≠t√°s ig√©nyes feladatok. K√ºl√∂n√∂sen j√≥l haszn√°lhat√≥ a felhaszn√°l√≥i fel√ºlet kialak√≠t√°s√°n√°l.</p><p>A protot√≠pus modell nagyban √©p√≠t a tesztel√©sre. Minden protot√≠pust felhaszn√°l√≥i √°tv√©teli tesztnek vetnek al√°, ami sor√°n k√∂nnyen kider√ºl, hogy milyen funkcion√°lis √©s nemfunkcion√°lis k√∂vetelm√©nyt nem tart be a protot√≠pus. A korai szakaszban sok unit-tesztet alkalmazunk. Amikor befejez√ºnk egy √∫jabb protot√≠pust, akkor regresszi√≥s teszttel vizsg√°ljuk meg, hogy ami az el&#337;z&#337; protot√≠pusban m&#369;k√∂d√∂tt, az tov√°bbiakban is m&#369;k√∂dik-e. Ha az √∫j protot√≠pusban van √∫j komponens is, akkor a r√©gi √©s az √∫j komponensek k√∂z√∂tt, illetve az √∫j &#8211; √∫j komponensek k√∂z√∂tt integr√°ci√≥s tesztet kell v√©grehajtani. A modell k√©s&#337;bbi szakasz√°ban, miut√°n m√°r a k√∂vetelm√©ny √©s a funkcion√°lis specifik√°ci√≥ letisztult, egy v√≠zes√©s modellre hasonl√≠t. Azaz az implement√°ci√≥ ut√°n j√∂n a tesztel√©s. Ekkor elv√©gezz√ºk √∫jb√≥l komponens √©s integr√°ci√≥s teszteket is. Rendszertesztet √°ltal√°ban csak a v√©gs&#337; protot√≠pus √°tad√°s el&#337;tt v√©gz√ºnk.</p></div><div class="sect2" title="2.3.3. Iterat√≠v √©s inkrement√°lis m√≥dszertanok"><div class="titlepage"><div><div><h3 class="title"><a name="d0e774"></a>2.3.3. 
      
               <a name="_Toc285293663"></a>Iterat√≠v √©s inkrement√°lis m√≥dszertanok</h3></div></div></div><p>Az iterat√≠v m√≥dszertan el&#337;√≠rja, hogy a fejleszt√©st, kezdve az ig√©nyfelm√©r√©st&#337;l az √ºzemeltet√©sig, kisebb iter√°ci√≥k sorozat√°ra bontsuk. Elt√©r&#337;en a v√≠zes√©s modellt&#337;l, amelyben p√©ld√°ul a tervez√©s teljesen megel&#337;zni az implement√°ci√≥t, itt minden iter√°ci√≥ban van tervez√©s √©s implement√°ci√≥i is. Lehet, hogy valamelyik iter√°ci√≥ban az egyik sokkal hangs√∫lyosabb, mint a m√°sik, de ez term√©szetes.</p><p>A folyamatos finom√≠t√°s lehet&#337;v√© teszi, hogy m√©lyen meg√©rts√ºk a feladatot √©s felder√≠ts√ºk az ellentmond√°sokat. Minden iter√°ci√≥ kieg√©sz√≠ti a m√°r kifejlesztett protot√≠pust. A kieg√©sz√≠t√©st inkrementumnak is nevezz√ºk. Azok a m√≥dszertanok, amik a folyamatra teszik a hangs√∫lyt, azaz az iter√°ci√≥ra, azokat iterat√≠v m√≥dszertanoknak nevezz√ºk. Azokat, amelyek az iter√°ci√≥ term√©k√©re, az inkrementumra teszik a hangs√∫lyt, azokat inkrement√°lis m√≥dszertanoknak h√≠vjuk. A mai m√≥dszertanok nagy r√©sze, kezdve a protot√≠pus modellt&#337;l eg√©szen az agilis modellekig, ebbe a csal√°dba tartoznak.</p><p>A kieg√©sz√≠t√©s hozz√°ad√°s√°val n√∂vekv&#337; r√©szrendszer j√∂n l√©tre, amelyet tesztelni kell. Az √∫j k√≥dot unit-teszttel tesztelj√ºk. Regresszi√≥s teszttel kell ellen&#337;rizni, hogy a r√©gi k√≥d tov√°bbra is m&#369;k√∂dik-e az √∫j k√≥d hozz√°ad√°sa √©s a v√°ltoz√°sok ut√°n. Az √∫j √©s a r√©gi k√≥d egy√ºttm&#369;k√∂d√©s√©t integr√°ci√≥s teszttel tesztelj√ºk. Ha egy m√©rf√∂ldk&#337;h√∂z vagy protot√≠pus bemutat√°shoz √©rkez√ºnk, akkor van felhaszn√°l√≥i √°tv√©teli teszt is. Egy√©bk√©nt csak egy bels&#337; √°tv√©teli teszt van az iter√°ci√≥ v√©g√©n.</p><p>
      
               <img src="images/kep4.png">
   
            </p><p>
      
               <img src="images/kep5.png">
   
            </p><p>Ezt a megk√∂zel√≠t√©st t√∂bb m√≥dszertan is alkalmazza, p√©ld√°ul a protot√≠pus modell, a gyors alkalmaz√°sfejleszt√©s (RAD), a Rational Unified Process (RUP) √©s az agilis fejleszt√©si modellek. Itt ezeknek a m√≥dszertanoknak a k√∂z√∂s r√©sz√©t, az iter√°ci√≥t ismertetj√ºk. Egy iter√°ci√≥ a k√∂vetkez&#337; feladatokb√≥l √°ll:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>‹zleti folyamatok elemz√©se</p></li><li class="listitem"><p>K√∂vetelm√©nyelemz√©s</p></li><li class="listitem"><p>Elemz√©s √©s tervez√©s</p></li><li class="listitem"><p>Implement√°ci√≥</p></li><li class="listitem"><p>Tesztel√©s</p></li><li class="listitem"><p>√©rt√©kel√©s</p></li></ol></div><p>Az iterat√≠v modell f&#337; ereje abban rejlik, hogy az √©letciklus l√©p√©sei nem egym√°s ut√°n j√∂nnek, mint a struktur√°lt m√≥dszertanok eset√©n, hanem id&#337;ben √°tfedik egym√°st. Minden iter√°ci√≥ban van elemz√©s, tervez√©s, implement√°ci√≥ √©s tesztel√©s. Ez√©rt, ha tal√°lunk egy f√©lre√©rt√©st, akkor nem kell visszal√©pni, hanem n√©h√°ny iter√°ci√≥ seg√≠ts√©g√©vel oldjuk fel a f√©lre√©rt√©st. Ez az jelenti, hogy kev√©sb√© tervezhet&#337; a fejleszt√©s ideje, de j√≥l alkalmazkodik az ig√©nyek v√°ltoz√°s√°hoz.</p><p>Mivel a fejleszt√©s l√©p√©seit mindig ism√©telgetj√ºk, ez√©rt azt mondjuk, hogy ezek id&#337;ben √°tfedik egym√°st, hiszen minden szakaszban minden l√©p√©st v√©gre kell hajtani. A kezdeti iter√°ci√≥kban t√∂bb az elemz√©s, a v√©g√©hez k√∂zeledve egyre t√∂bb a tesztel√©s. M√°r a legels&#337; szakaszban is van tesztel√©s, de ekkor m√©g csak a teszttervet k√©sz√≠tj√ºk. M√°r a legels&#337; szakaszban is van implement√°ci√≥, de ekkor m√©g csak az architekt√∫ra oszt√°lyait hozzuk l√©tre. √©s √≠gy tov√°bb.</p><p>A feladatot t√∂bb iter√°ci√≥ra bontjuk. Ezeket √°ltal√°ban t√∂bb kisebb csapat implement√°lja egym√°ssal versengve. Aki gyorsabb, az v√°laszthat iter√°ci√≥t a megl√©v&#337;k k√∂z√ºl. A v√°laszt√°s nem teljesen szabad, a legnagyobb priorit√°s√∫ feladatok k√∂z√ºl kell v√°lasztani. A priorit√°s meghat√°roz√°sa k√ºl√∂nb√∂z&#337; lehet, √°ltal√°ban a leggyorsabban megval√≥s√≠that√≥ √©s legnagyobb √ºzleti √©rt√©k&#369;, azaz a legnagyobb √ºzleti megt√©r√ºl√©ssel (angolul: return of investment) b√≠r√≥ feladat a legnagyobb priorit√°s√∫.</p><p>‹zleti folyamatok elemz√©se: Els&#337; l√©p√©sben meg kell ismerni a megrendel&#337; √ºzleti folyamatait. Az √ºzleti folyamatok modellez√©se sor√°n fel kell √°ll√≠tani egy projekt fogalomt√°rat. A lemodellezett √ºzleti folyamatokat egyeztetni kell a megrendel&#337;vel, hogy ellen&#337;rizz√ºk j√≥l √©rtj√ºk-e az √ºzleti logik√°t. Ezt √ºzleti elemz&#337;k v√©gzik, akik a megrendel&#337;k √©s a fejleszt&#337;k fej√©vel is k√©pesek gondolkozni.</p><p>K√∂vetelm√©nyelemz√©s: A k√∂vetelm√©ny elemz√©s sor√°n meghat√°rozzuk a rendszer funkcion√°lis √©s nemfunkcion√°lis k√∂vetelm√©nyeit, majd ezekb&#337;l funkci√≥kat, k√©perny&#337;terveket k√©sz√≠t√ºnk. Ez a l√©p√©s az eg√©sz fejleszt√©s elej√©n nagyon hangs√∫lyos, hiszen a kezdeti iter√°ci√≥k c√©lja a k√∂vetelm√©nyek fel√°ll√≠t√°sa. K√©s&#337;bbiekben csak a funkcion√°lis terv finom√≠t√°sa a feladata. Fontos, hogy a k√∂vetelm√©nyeket egyeztess√ºk a megrendel&#337;kkel. Ha a finom√≠t√°s sor√°n ellentmond√°st fedez√ºnk fel, akkor √©rdemes tiszt√°zni a k√©rd√©st a megrendel&#337;vel.</p><p>Elemz√©s √©s tervez√©s: Az elemz√©s √©s tervez√©s sor√°n a k√∂vetelm√©ny elemz√©s term√©keib&#337;l megpr√≥b√°ljuk elemezni a rendszert √©s megtervezni azt. A nemfunkcion√°lis k√∂vetelm√©nyekb&#337;l lesz az architektur√°lis terv. Az architektur√°lis terv alapj√°n tervezz√ºk az alrendszereket √©s a k√∂zt√ºk lev&#337; kapcsolatokat. Ez a kezdeti iter√°ci√≥k feladata. A funkcion√°lis k√∂vetelm√©nyek alapj√°n tervezz√ºk meg az oszt√°lyokat, met√≥dusokat √©s az adatt√°bl√°kat. Ezek a k√©s&#337;bbi iter√°ci√≥k feladatai.</p><p>Implement√°ci√≥: Az implement√°ci√≥s szakaszra ritk√°n adnak megszor√≠t√°st az iterat√≠v m√≥dszertanok. √°ltal√°ban a bevett technik√°k alkalmaz√°s√°t aj√°nlj√°k, illetve szerepk√∂r√∂ket √≠rnak el&#337;. Pl.: a fejleszt&#337;k fejlesztik a rendszert, a fejleszt&#337;k szoros kapcsolatban vannak a tervez&#337;kkel, tov√°bb√° van egy k√≥d ellen&#337;r, aki ellen&#337;rzi, hogy a fejleszt&#337;k √°ltal √≠rt programok megfelelnek-e a tervez&#337;k √°ltal kital√°lt tervez√©si √©s programoz√°si ir√°nyelveknek. Ebben a szakaszban a programoz√≥k unit-teszttel biztos√≠tj√°k a k√≥d min&#337;s√©g√©t.</p><p>Tesztel√©s: A tesztel√©si szakaszban k√ºl√∂nb√∂z&#337; tesztel√©si eseteket tal√°lunk ki, ezeket unit-tesztk√©nt val√≥s√≠tjuk meg. Itt vizsg√°ljuk meg, hogy az elk√©sz√ºlt k√≥d k√©pes-e egy√ºttm&#369;k√∂dni a program t√∂bbi r√©sz√©vel, azaz integr√°ci√≥s tesztet hajtunk v√©gre. Regresszi√≥s tesztek seg√≠ts√©g√©vel ellen&#337;rizz√ºk, hogy ami eddig k√©sz volt, az nem romlott el. Ehhez lefuttatjuk az √∂sszes unit-tesztet. Rendszerteszt csak a k√©s&#337;i tesztel√©si f√°zisokban van.</p><p>√©rt√©kel√©s: A fejleszt√©s minden ciklus√°ban el kell d√∂nteni, hogy az elk√©sz√ºlt verzi√≥t elfogadjuk-e, vagy sem. Ha nem, akkor √∫jra indul ez az iter√°ci√≥. Ha igen, v√©ge ennek az iter√°ci√≥nak. Az √≠gy elk√©sz√ºlt k√≥dot felt√∂ltj√ºk a verzi√≥k√∂vet&#337; rendszerbe, hogy a t√∂bbi csapat is hozz√°f√©rjen. Az √©rt√©kel√©s mag√°ban foglal egy √°tv√©teli tesztet is. Ha a megrendel&#337; nem √°ll rendelkez√©sre, akkor √°ltal√°ban a csoportok munk√°j√°t √∂sszefog√≥ vezet&#337; programoz√≥ / tervez&#337; helyettes√≠ti. Amennyiben a folyamat sor√°n el√©rt√ºnk egy m√©rf√∂ldk&#337;h√∂z, akkor √°ltal√°ban √°t kell adnunk egy k√∂ztes protot√≠pust is. Ekkor mindig rendelkez√©sre √°ll a megrendel&#337;, hogy elv√©gezz√ºk a felhaszn√°l√≥i √°tv√©teli tesztet.</p><p>T√°mogat√≥ tev√©kenys√©gek, napi ford√≠t√°s: Az iter√°ci√≥kt√≥l f√ºggetlen√ºl √∫gynevezett t√°mogat√≥ folyamatok is zajlanak a szoftver c√©gen bel√ºl. Ilyen p√©ld√°ul a rendszergazd√°k vagy a menedzsment tev√©kenys√©ge. Az iter√°ci√≥k szemsz√∂g√©b&#337;l a legfontosabb az √∫gynevezett a napi ford√≠t√°s (daily build). Ez azt jelenti, hogy minden nap v√©g√©n a verzi√≥k√∂vet&#337; rendszerben l√©v&#337; forr√°sk√≥dot leford√≠tjuk. Minden csapat igyekszik a megl√©v&#337; k√≥dhoz igaz√≠tani a saj√°tj√°t, hogy lehets√©ges legyen a ford√≠t√°s. Aki elrontja a napi ford√≠t√°st, √©s ezzel nehez√≠ti az √∂sszes csapat k√∂vetkez&#337; napi munk√°j√°t, az b√ºntet√©sre sz√°m√≠that. Ez a c√©g hagyom√°nyait√≥l f√ºgg, √°ltal√°ban egy h√©tig &#337; csin√°lja a napi ford√≠t√°s √©s emiatt sokszor sok√°ig bent kell maradnia.</p><p>V√©g√ºl vagy el√©rj√ºk azt a pontot, ahol azt mondjuk, hogy ez √≠gy nem elk√©sz√≠thet&#337;, vagy azt mondjuk, hogy minden felmer√ºlt ig√©nyt kiel√©g√≠t a szoftver√ºnk √©s sz√°ll√≠thatjuk a megrendel&#337;nek.</p></div><div class="sect2" title="2.3.4. Gyors alkalmaz√°sfejleszt√©s &#8211; RAD"><div class="titlepage"><div><div><h3 class="title"><a name="d0e836"></a>2.3.4. 
      
               <a name="_Toc285293664"></a>Gyors alkalmaz√°sfejleszt√©s &#8211; RAD</h3></div></div></div><p>A gyors alkalmaz√°sfejleszt√©s vagy ismertebb nev√©n RAD (Rapid Application Development) egy olyan elgondol√°s, amelynek l√©nyege a szoftver gyorsabb √©s jobb min&#337;s√©g&#369; elk√©sz√≠t√©se. Ezt a k√∂vetkez&#337;k √°ltal √©rhetj√ºk el:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Korai protot√≠pus k√©sz√≠t√©s √©s ism√©tl&#337;d&#337; felhaszn√°l√≥i √°tv√©teli tesztek.</p></li><li class="listitem"><p>A csapat - megrendel&#337; √©s a csapaton bel√ºli kommunik√°ci√≥ban kev√©sb√© form√°lis.</p></li><li class="listitem"><p>Szigor√∫ √ºtemterv, √≠gy az √∫j√≠t√°sok mindig csak a term√©k k√∂vetkez&#337; verzi√≥j√°ban jelennek meg.</p></li><li class="listitem"><p>K√∂vetelm√©nyek √∂sszegy&#369;jt√©se f√≥kusz csoportok √©s munka√©rtekezletek haszn√°lat√°val.</p></li><li class="listitem"><p>Komponensek √∫jrahasznos√≠t√°sa.</p></li></ol></div><p>Ezekhez a folyamatokhoz t√∂bb szoftvergy√°rt√≥ is k√©sz√≠tett seg√©deszk√∂z√∂ket, melyek r√©szben vagy eg√©szben lefedik a fejleszt√©s f√°zisait, mint p√©ld√°ul:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>k√∂vetelm√©ny √∂sszegy&#369;jt&#337; eszk√∂z√∂k,</p></li><li class="listitem"><p>tervez√©st seg√≠t&#337; eszk√∂z√∂k,</p></li><li class="listitem"><p>protot√≠pus k√©sz√≠t&#337; eszk√∂z√∂k,</p></li></ol></div><p>csapatok kommunik√°ci√≥j√°t seg√≠t&#337; eszk√∂z√∂k.</p><p>A RAD els&#337;sorban az objektumorient√°lt programoz√°ssal kacsol√≥dik √∂ssze, m√°r csak a komponensek √∫jrahasznos√≠t√°sa ok√°n is. ÷sszehasonl√≠tva a hagyom√°nyos fejleszt√©si met√≥dusokkal (pl.: v√≠zes√©s modell), ahol az egyes fejleszt√©si f√°zisok j√≥l elk√ºl√∂n√ºlnek egym√°st√≥l, a RAD sokkal rugalmasabban. Gyakori probl√©ma, hogy a tervez√©sbe hiba cs√∫szik, √©s az csak a megval√≥s√≠t√°si vagy a tesztel√©si f√°zisban j√∂n el&#337;, r√°ad√°sul az elemz√©s √©s a tesztel√©si f√°zis k√∂z√∂tt hat-h√©t h√≥nap is eltelhet. Vagy ha menetk√∂zbe megv√°ltoznak az √ºzleti k√∂r√ºlm√©nyek, √©s m√°r a megval√≥s√≠t√°si f√°zisban j√°runk, vagy csak r√°j√∂ttek a megrendel&#337;k, hogy valamit m√©gis m√°sk√©ppen szeretn√©nek, akkor szint√©n gondban vagyunk. A RAD v√°lasza ezekre a probl√©m√°kra a gyorsas√°g. Ha gyorsan hozzuk l√©tre a rendszert, akkor ezen r√∂vid id&#337; alatt nem v√°ltoznak a k√∂vetelm√©nyek, az elemz√©s √©s tesztel√©s k√∂z√∂tt nem hat-h√©t h√≥nap, hanem csak hat-h√©t h√©t telik el.</p><p>A gyorsas√°g el√©r√©s√©hez sok megl√©v&#337; komponenst kell felhaszn√°lni, amit a csapatnak j√≥l kell ismernie. A komponensek lehetnek saj√°t fejleszt√©s&#369;ek vagy megv√°s√°roltak. Komponenst v√°s√°rolni nagy kock√°zat, mert ha hiba van benne, azt nem tudjuk jav√≠tani, ha nem kapjuk meg a forr√°st, de m√©g √∫gy is nagyon neh√©z. Ez√©rt a komponens gy√°rt√≥k nagyon alaposan tesztelik term√©k√ºket.</p><p>A RAD az elemz√©st, a tervez√©st, a megval√≥s√≠t√°st, √©s a tesztel√©st r√∂vid, ism√©tl&#337;d&#337; ciklusok sorozat√°ba t√∂m√∂r√≠ti, √©s ennek sok el&#337;nye van a hagyom√°nyos modellekkel szemben. A fejleszt√©s sor√°n √°ltal√°ban kis csoportokat hoznak l√©tre fejleszt&#337;kb&#337;l, v√©gfelhaszn√°l√≥kb√≥l, ez az √∫gynevezett f√≥kusz csoport. Ezek a csapatok az ism√©tl&#337;d&#337;, r√∂vid ciklusokkal vegy√≠tve hat√©konyabb√° teszik a kommunik√°ci√≥t, optimaliz√°lj√°k a fejleszt√©si sebess√©get, egys√©ges√≠tik az elk√©pzel√©seket √©s c√©lokat, valamint leegyszer&#369;s√≠tik a folyamat fel√ºgyelet√©t.</p><p>÷t fejleszt√©si l√©p√©s a RAD-ban:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>‹zleti modellez√©s: Az √ºzleti funkci√≥k k√∂z√∂tti inform√°ci√≥ √°raml√°st olyan k√©rd√©sek feltev√©s√©vel tudjuk felder√≠teni, mint hogy milyen inform√°ci√≥k keletkeznek, ezeket ki √°ll√≠tja el&#337;, az √ºzleti folyamatot milyen inform√°ci√≥k ir√°ny√≠tj√°k, vagy hogy ki ir√°ny√≠tja.</p></li><li class="listitem"><p>Adat modellez√©s: Az √ºzleti modellez√©ssel √∂sszegy&#369;jt√∂tt√ºk a sz√ºks√©ges adatokat, melyekb&#337;l adat objektumokat hozunk l√©tre. Beazonos√≠tjuk az attrib√∫tumokat √©s a kapcsolatokat az adatok k√∂z√∂tt.</p></li><li class="listitem"><p>Folyamat modellez√©s: Az el&#337;z&#337;leg l√©trehozott adatmodellhez sz√ºks√©ges m&#369;veletek (b&#337;v√≠t√©s, t√∂rl√©s, m√≥dos√≠t√°s) meghat√°roz√°sa, √∫gy hogy l√©trehozzuk a kell&#337; inform√°ci√≥√°raml√°st az √ºzleti funkci√≥k sz√°m√°ra.</p></li><li class="listitem"><p>Alkalmaz√°s el&#337;√°ll√≠t√°sa: A szoftver el&#337;√°ll√≠t√°s√°nak megk√∂nny√≠t√©se automatikus eszk√∂z√∂kkel.</p></li><li class="listitem"><p>Tesztel√©s: Az √∫j programkomponensek tesztel√©se, a m√°r kor√°bban tesztelt komponenseket m√°r nem sz√ºks√©ges √∫jra vizsg√°lni. Ez gyors√≠tja a folyamatot.</p></li></ol></div><p>
      
               <img src="images/kep6.png">
   
            </p><p>H√°tr√°nya, hogy magasan k√©pzett fejleszt&#337;kre van sz√ºks√©g, emellett fontos a fejleszt&#337;k √©s a v√©gfelhaszn√°l√≥k elk√∂telezetts√©ge a sikeres szoftver ir√°nt. Ha a projekt nehezen bonthat√≥ fel modulokra, akkor nem a legjobb v√°laszt√°s a RAD. Nagyobb rendszerek fejleszt√©se ezzel a m√≥dszertannal kock√°zatos.</p></div><div class="sect2" title="2.3.5. Agilis szoftverfejleszt√©s"><div class="titlepage"><div><div><h3 class="title"><a name="d0e903"></a>2.3.5. 
      
               <a name="_Toc285293665"></a>Agilis szoftverfejleszt√©s</h3></div></div></div><p>Az agilis szoftverfejleszt√©s val√≥j√°ban iterat√≠v szoftverfejleszt√©si m√≥dszerek egy csoportj√°ra utal, amelyet 2001-ben az Agile Manifesto nev&#369; kiadv√°nyban √∂nt√∂ttek form√°ba. Az agilis fejleszt√©si m√≥dszerek (nevezik adapt√≠vnak is) egyik fontos jellemz&#337;je, hogy a r√©sztvev&#337;k, amennyire lehets√©ges megpr√≥b√°lnak alkalmazkodni a projekthez. Ez√©rt fontos p√©ld√°ul, hogy a fejleszt&#337;k folyamatosan tanuljanak.</p><p>Az agilis szoftverfejleszt√©s szerint √©rt√©kesebbek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>az egy√©nek √©s interaktivit√°s szemben a folyamatokkal √©s az eszk√∂z√∂kkel,</p></li><li class="listitem"><p>a m&#369;k√∂d&#337; szoftver szemben a terjedelmes dokument√°ci√≥val,</p></li><li class="listitem"><p>az egy√ºttm&#369;k√∂d√©s a megrendel&#337;vel szemben a szerz&#337;d√©ses t√°rgyal√°sokkal,</p></li><li class="listitem"><p>az alkalmazkod√°s a v√°ltoz√°sokhoz szemben a terv k√∂vet√©s√©vel.</p></li></ol></div><p>Az agilis szoftverfejleszt√©s alapelvei:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A legfontosabb a megrendel&#337; kiel√©g√≠t√©se haszn√°lhat√≥ szoftver gyors √©s folyamatos √°tad√°s√°val.</p></li><li class="listitem"><p>M√©g a k√∂vetelm√©nyek k√©sei v√°ltoztat√°sa sem okoz probl√©m√°t.</p></li><li class="listitem"><p>A m&#369;k√∂d&#337; szoftver / protot√≠pus √°tad√°sa rendszeresen, a lehet&#337; legr√∂videbb id&#337;n bel√ºl.</p></li><li class="listitem"><p>Napi egy√ºttm&#369;k√∂d√©s a megrendel&#337; √©s a fejleszt&#337;k k√∂z√∂tt.</p></li><li class="listitem"><p>A projektek motiv√°lt egy√©nek k√∂r√© √©p√ºlnek, akik megkapj√°k a sz√ºks√©ges eszk√∂z√∂ket √©s t√°mogat√°st a legjobb munkav√©gz√©shez.</p></li><li class="listitem"><p>A leghat√©konyabb kommunik√°ci√≥ a szemt&#337;l-szembeni megbesz√©l√©s.</p></li><li class="listitem"><p>Az el&#337;rehalad√°s alapja a m&#369;k√∂d&#337; szoftver.</p></li><li class="listitem"><p>Az agilis folyamatok √°ltali fenntarthat√≥ fejleszt√©s √°lland√≥ √ºtemben.</p></li><li class="listitem"><p>Folyamatos figyelem a technikai kit&#369;n&#337;s√©gnek.</p></li><li class="listitem"><p>Egyszer&#369;s√©g, a min√©l nagyobb hat√©konys√°g√©rt.</p></li><li class="listitem"><p>÷nszervez&#337; csapatok k√©sz√≠tik a legjobb terveket.</p></li><li class="listitem"><p>Rendszeres id&#337;k√∂z√∂nk√©nt a csapatok reag√°lnak a v√°ltoz√°sokra, hogy m√©g hat√©konyabbak legyenek.</p></li></ol></div><p>Az agilis szoftverfejleszt√©snek nagyon sok fajt√°ja van. Ebben a jegyzetben csak ezt a kett&#337;t t√°rgyaljuk:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Scrum</p></li><li class="listitem"><p>Extr√©m Programoz√°s (XP)</p></li></ol></div><p>Ezek a k√∂vetkez&#337; k√∂z√∂s jellemz&#337;kkel b√≠rnak:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Kevesebb dokument√°ci√≥.</p></li><li class="listitem"><p>N√∂vekv&#337; rugalmass√°g, cs√∂kken&#337; kock√°zat.</p></li><li class="listitem"><p>K√∂nnyebb kommunik√°ci√≥, javul√≥ egy√ºttm&#369;k√∂d√©s.</p></li><li class="listitem"><p>A megrendel&#337; bevon√°sa a fejleszt√©sbe.</p></li></ol></div><p>Kevesebb dokument√°ci√≥: Az agilis met√≥dusok alapvet&#337; k√ºl√∂nbs√©ge a hagyom√°nyosakhoz k√©pest, hogy a projektet apr√≥ r√©szekre bontj√°k, √©s mindig egy kisebb darabot tesznek hozz√° a term√©khez, ezeket egyt&#337;l n√©gy h√©tig terjed&#337; ciklusokban (m√°s n√©ven keretekben vagy id&#337;dobozokban) k√©sz√≠tik el, √©s ezek a ciklusok ism√©tl&#337;dnek. Ez√°ltal nincs olyan jelleg&#369; r√©szletes hossz√∫ t√°v√∫ tervez√©s, mint p√©ld√°ul a v√≠zes√©ses modelln√©l, csak az a minim√°lis, amire az adott ciklusban sz√ºks√©g van. Ez abb√≥l az elvb&#337;l indul ki, hogy nem lehet el&#337;re t√∂k√©letesen, minden r√©szletre kiterjed&#337;en megtervezni egy szoftvert, mert vagy a tervben lesz hiba, vagy a megrendel&#337; v√°ltoztat valamit.</p><p>N√∂vekv&#337; rugalmass√°g, cs√∂kken&#337; kock√°zat: Az agilis m√≥dszerek a v√°ltoz√°sokhoz adapt√°lhat√≥ technik√°kat helyezik el&#337;nybe a j√≥l tervezhet&#337; technik√°kkal szemben. Ennek megfelel&#337;en iter√°ci√≥kat haszn√°lnak. Egy iter√°ci√≥ olyan, mint egy hagyom√°nyos √©letciklus: tartalmazza a tervez√©st, a k√∂vetelm√©nyek elemz√©s√©t, a k√≥dol√°st, √©s a tesztel√©st. Egy iter√°ci√≥ maximum egy h√≥nap terjedelm&#369;, √≠gy n&#337; a rugalmass√°g, valamint cs√∂kken a kock√°zat, hiszen az iter√°ci√≥ v√©g√©n √°tv√©teli teszt van, ami ut√°n megrendel&#337; megv√°ltoztathatja eddigi k√∂vetelm√©nyeit. Minden iter√°ci√≥ v√©g√©n fut√≥k√©pes v√°ltozatot kell kiadniuk a csapatoknak a kez√ºkb&#337;l.</p><p>K√∂nnyebb kommunik√°ci√≥, javul√≥ egy√ºttm&#369;k√∂d√©s: Jellemz&#337;, hogy a fejleszt&#337; csoportok √∂nszervez&#337;ek, √©s √°ltal√°ban nem egy feladatra specializ√°l√≥dottak a tagok, hanem t√∂bbf√©le szakter√ºletr&#337;l ker√ºlnek egy csapatba, √≠gy p√©ld√°ul programozok √©s tesztel&#337;k. Ezek a csapatok ide√°lis esetben egy helyen, egy irod√°ban dolgoznak, a csapatok m√©rete ide√°lis esetben 5-9 f&#337;. Mindez leegyszer&#369;s√≠ti a tagok k√∂z√∂tti kommunik√°ci√≥t √©s seg√≠ti a csapaton bel√ºli egy√ºttm&#369;k√∂d√©st. Az agilis m√≥dszerek el&#337;nyben r√©szes√≠tik a szemt&#337;l szembe folytatott kommunik√°ci√≥t az √≠r√°sban folytatott eszmecser√©vel szemben.</p><p>A megrendel&#337; bevon√°sa a fejleszt√©sbe: Vagy szem√©lyesen a megrendel&#337; vagy egy kijel√∂lt szem√©ly, aki elk√∂telezi mag√°t a term√©k elk√©sz√≠t√©se mellett, folyamatosan a fejleszt&#337;k rendelkez√©s√©re √°ll, hogy a menet k√∂zben felmer√ºl&#337; k√©rd√©seket min√©l hamarabb meg tudja v√°laszolni. Ez a szem√©ly a ciklus v√©g√©n is r√©szt vesz az elk√©sz√ºlt protot√≠pus ki√©rt√©kel√©s√©ben. Fontos feladata az elk√©sz√≠tend&#337; funkci√≥k fontoss√°gi sorrendj√©nek fel√°ll√≠t√°sa azok √ºzleti √©rt√©ke alapj√°n. Az √ºzleti √©rt√©kb&#337;l √©s a fejleszt&#337; csapat √°ltal becs√ºlt fejleszt√©si id&#337;b&#337;l sz√°molhat√≥ a befektet√©s megt√©r√ºl√©se (Return of Investment, ROI). A befektet√©s megt√©r√ºl√©se az √ºzleti √©rt√©k √©s a fejleszt√©si id&#337; h√°nyadosa.</p><p>Az agilis m√≥dszertanok nagyon j√≥l m&#369;k√∂dnek, am√≠g a feladatot egy k√∂zepes m√©ret&#369; (5-9 f&#337;s) csapat k√©pes megoldani. Nagyobb csoportok eset√©n neh√©z a csapat szellem kialak√≠t√°sa. Ha t√∂bb csoport dolgozik ugyanazon a c√©lon, akkor k√∂zt√ºk a kommunik√°ci√≥ neh√©zkes. Ha megrendel&#337; nem hajland√≥ egy elk√∂telezett munkat√°rs√°t a fejleszt&#337; csapat rendelkez√©s√©re bocs√°tani, akkor az kiv√°lthat√≥ egy √ºzleti elemz&#337;vel, aki √°tl√°tja a megrendel&#337; √ºzleti folyamatait, de ez kock√°zatos.</p></div><div class="sect2" title="2.3.6. Scrum"><div class="titlepage"><div><div><h3 class="title"><a name="d0e998"></a>2.3.6. 
      
               <a name="_Toc285293666"></a>Scrum</h3></div></div></div><p>A Scrum egy agilis szoftverfejleszt√©si met√≥dus. Jellegzetess√©ge, hogy fogalmait az amerikai futballb√≥l, m√°s n√©ven rugby, mer√≠ti. Ilyen fogalom, maga a Scrum is, amely dulakod√°st jelent. A m√≥dszertan jelent&#337;s szerepet tulajdon√≠t a csoporton bel√ºli √∂sszetart√°snak. A csoporton bel√ºl sok a tal√°lkoz√≥, a kommunik√°ci√≥, lehet&#337;s√©g van a gondok megbesz√©l√©sre is. Az aj√°nl√°s szerint j√≥, ha a csapat egy helyen dolgozik √©s sz√≥ban kommunik√°l.</p><p>A Scrum √°ltal el&#337;√≠rt fejleszt√©si folyamat r√∂viden √≠gy foglalhat√≥ √∂ssze: A Product Owner l√©trehoz egy Product Backlog-ot, amelyre a teend&#337;ket felhaszn√°l√≥i sztorik√©nt veszi fel. A sztorikat priorit√°ssal kell ell√°tni √©s megmondani, mi az √ºzleti √©rt√©k√ºk. Ez a Product Owner feladata. A Sprint Planning Meetingen a csapat tagjai megbesz√©lik, hogy mely sztorik megval√≥s√≠t√°s√°t v√°llalj√°k el, lehet&#337;leg a legnagyobb priorit√°s√∫akat. Ehhez a sztorikat kisebb feladatokra bontj√°k, hogy megbecs√ºlhess√©k mennyi ideig tart megval√≥s√≠tani azokat. Ezut√°n j√∂n a sprint, ami 2-4 h√©tig tart. A sprint id&#337;tartam√°t az elej√©n fix√°lja a csapat, ett&#337;l elt√©rni nem lehet. Ha nem siker√ºl befejezni az adott id&#337;tartam alatt, akkor sikertelen a sprint, ami b√ºntet√©st, √°ltal√°ban pr√©mium megvon√°st, von maga ut√°n. A sprinten bel√ºl a csapat √©s a Scrum Master naponta megbesz√©lik a t√∂rt√©nteket a Daily Meetingen. Itt mindenki elmondja, hogy mit csin√°lt, mi lesz a k√∂vetkez&#337; feladata, √©s milyen akad√°lyokba (impediment) √ºtk√∂z√∂tt. A sprint v√©g√©n k√∂vetkezik a Sprint Review, ahol a csapat bemutatja a sprint alatt elk√©sz√ºlt sztorikat. Ezeket vagy elfogadj√°k, vagy nem. Majd a Sprint Retrospective tal√°lkoz√≥ k√∂vetkezik, ahol a Sprint sor√°n felmer√ºlt probl√©m√°kat t√°rgyalja √°t a csapat. A megold√°sra konkr√©t javaslatokat kell tenni. Ezek ut√°n √∫jra a Sprint Planning Meeting k√∂vetkezik. A fejlesztett term√©k az el&#337;tt piacra ker√ºlhet, hogy minden sztorit megval√≥s√≠tottak volna.</p><p>A csapatban minden szerepk√∂r k√©pvisel&#337;je megtal√°lhat√≥, √≠gy van benne fejleszt&#337; √©s tesztel&#337; is. T√©ves azt gondolni, hogy a sprint elej√©n a tesztel&#337; is programot √≠r, hiszen, am√≠g nincs program, nincs mit tesztelni. Ezzel szemben a tesztel&#337; a sprint elej√©n a tesztel&#337; a teszttervet k√©sz√≠t, majd kidolgozza a teszteseteket, v√©g√ºl, amikor m√°r vannak k√©sz oszt√°lyok, unit-teszteket √≠r, a v√°ltoz√°sokat regresszi√≥s teszttel ellen&#337;rzi.</p><p>A Scrum, mint minden agilis m√≥dszertan, arra √©p√≠t, hogy a fejleszt√©s k√∂zben a megrendel&#337; ig√©nyei v√°ltozhatnak. A v√°ltoz√°sokhoz √∫gy alkalmazkodik, a Product Backlog folyamatosan v√°ltozhat. Az erre √©p√ºl&#337; dokumentumok folyamatosan finomodnak, teh√°t k√∂nnyen v√°ltoztathat√≥k. A csapatok gyorsan megval√≥s√≠tj√°k a sz√ºks√©ges v√°ltoz√°sokat.</p><p>A Scrum t√∂k√©lyre viszi az egy csapaton bel√ºli hat√©konys√°got. Ha t√∂bb csapat is dolgozik egy fejleszt√©sen, akkor k√∂zt√ºk lehetnek kommunik√°ci√≥s zavarok, ami a m√≥dszertan egyik h√°tr√°nya.</p><p>
      
               <img src="images/kep7.png">
   
            </p><p>A Scrum k√©t nagyon fontos fogalma a sprint √©s az akad√°ly.</p><p>Sprint (vagy futam): Egy el&#337;re megbesz√©lt hossz√∫s√°g√∫ fejleszt√©si id&#337;szak, √°ltal√°ban 2-4 h√©tig tart, kezd&#337;dik a Sprint Planning-gel, majd a Retrospective-vel z√°rul. Ez a Scrum √∫gynevezett iter√°ci√≥s ciklusa, addig kell ism√©telni, am√≠g a Product Backlog-r√≥l el nem t&#369;nnek a megold√°sra v√°r√≥ felhaszn√°l√≥i sztorik. Alapelv, hogy minden sprint v√©g√©re egy potenci√°lisan lesz√°ll√≠that√≥ szoftvert kell el&#337;√°ll√≠tani a csapatnak, azaz egy protot√≠pust. A sprint tekinthet&#337; k√©t m√©rf√∂ldk&#337; k√∂zti munk√°nak.</p><p>Akad√°ly (Impediment): Olyan g√°tl√≥ t√©nyez&#337;, amely a munk√°t h√°tr√°ltatja. Csak √©s kiz√°r√≥lag munkahelyi probl√©ma tekinthet&#337; akad√°lynak. A csapattagok mag√°n√©leti probl√©m√°i nem azok. Akad√°ly p√©ld√°ul, hogy lej√°rt az egyik szoftver licence, vagy sz√ºks√©g lenne egy plusz g√©pre a gyorsabb halad√°shoz, vagy t√∂bb mem√≥ri√°ra az egyik g√©pbe, vagy ak√°r az is lehet, hogy 2 tag megs√©rt&#337;d√∂tt egym√°sra. Ilyenkor kell a Scrum Masternek elh√°r√≠tani az akad√°lyokat, hogy a munka min√©l g√∂rd√ºl√©kenyebb legyen.</p><p>A m√≥dszertan szerepk√∂r√∂ket, megbesz√©l√©seket √©s elk√©sz√≠tend&#337; term√©keket √≠r el&#337;.</p><div class="sect3" title="2.3.6.1. Szerepk√∂r√∂k"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1025"></a>2.3.6.1. Szerepk√∂r√∂k</h4></div></div></div><p>A m√≥dszertan k√©tf√©le szerepk√∂rt k√ºl√∂nb√∂ztet meg, ezek a diszn√≥k √©s a csirk√©k. A megk√ºl√∂nb√∂ztet√©s alapja egy vicc:</p><p>A diszn√≥ √©s a csirke mennek az utc√°n. Egyszer csak a csirke megsz√≥lal: &#8222;Te, nyissunk egy √©ttermet!&#8221; Mire a diszn√≥: &#8222;J√≥ √∂tlet, mi legyen a neve?&#8221; A csirke gondolkozik, majd r√°v√°gja: &#8222;Nevezz√ºk Sonk√°stoj√°snak!&#8221; A diszn√≥ erre: &#8222;Nem tetszik valahogy, mert √©n biztosan mindent beleadn√©k, te meg √©ppen csak hogy r√©szt venn√©l benne.&#8221;</p><p>A diszn√≥k azok, akik elk√∂telezettek a szoftver projekt siker√©ben. &#336;k azok, akik a &#8222;v√©r√ºket&#8221; adj√°k a projekt siker√©√©rt, azaz felel&#337;ss√©get v√°llalnak √©rte. A csirk√©k is √©rdekeltek a projekt siker√©ben, &#337;k a haszon√©lvez&#337;i a sikernek, de ha esetleg m√©gse sikeres a projekt, akkor az nem az &#337; felel&#337;ss√©g√ºk.</p><p>Diszn√≥k:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Scrum mester (Scrum Master)</p></li><li class="listitem"><p>Term√©ktulajdonos (Product Owner)</p></li><li class="listitem"><p>Csapat (Team)</p></li></ol></div><p>Csirk√©k:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>‹zleti szerepl&#337;k (Stakeholders)</p></li><li class="listitem"><p>Menedzsment (Managers)</p></li></ol></div><p>Scrum mester (Scrum Master): A Scrum mester fel√ºgyeli √©s megk√∂nny√≠ti a folyamat fenntart√°s√°t, seg√≠ti a csapatot, ha probl√©m√°ba √ºtk√∂zik, illetve fel√ºgyeli, hogy mindenki betartja-e a Scrum alapvet&#337; szab√°lyait. Ilyen p√©ld√°ul, hogy a Sprint id&#337;tartama nem t√©rhet el az el&#337;re megbesz√©ltt&#337;l, m√©g akkor sem, ha az elv√°llalt munka nem lesz k√©sz. Akkor is nemet kell mondania, ha a Product Owner a sprint k√∂zben azt tal√°lja ki, hogy az egyik sztorit, amit nem v√°llaltak be az adott id&#337;szakra, el kellene k√©sz√≠teni, mert mondjuk megv√°ltoztak az √ºzleti k√∂r√ºlm√©nyek. L√©nyeg√©ben &#337; a projekt menedzser.</p><p>Term√©k tulajdonos (Product Owner): A megrendel&#337; szerep√©t t√∂lti be, &#337; a felel&#337;s az√©rt, hogy a csapat mindig azt a r√©sz√©t fejlessze a term√©knek, amely √©ppen a legfontosabb, vagyis a felhaszn√°l√≥i sztorik fontoss√°gi sorrendbe √°ll√≠t√°sa a feladata a Product Backlog-ban. A Product Owner √©s a Scrum Master nem lehet ugyanaz a szem√©ly.</p><p>Csapat (Team): &#336;k a felel&#337;sek az√©rt, hogy az aktu√°lis sprintre bev√°llalt feladatokat elv√©gezz√©k, ide√°lis esetben 5-9 f&#337; alkot egy csapatot. A csapatban helyet kapnak a fejleszt&#337;k, tesztel&#337;k, elemz&#337;k. √≠gy nem a v√°lt√≥fut√°sra jellemz&#337; staf√©tav√°lt√°s (mint a v√≠zes√©s modelln√©l), hanem a futballra eml√©keztet&#337; passzolgat√°s, azaz igazi csapatj√°t√©k jellemzi a csapatot.</p><p>‹zleti szerepl&#337;k, pl.: megrendel&#337;k, forgalmaz√≥k (Stakeholders, i.e., customers, vendors): A megrendel&#337; √°ltal j√∂n l√©tre a projekt, &#337; az, aki majd a haszn√°t l√°tja a term√©k elk√©sz√≠t√©s√©nek, a Sprint Review sor√°n kap szerepet a folyamatban.</p><p>Menedzsment (Managers): A menedzsment feladata a megfelel&#337; k√∂rnyezet fel√°ll√≠t√°sa a csapatok sz√°m√°ra. √°ltal√°ban a megfelel&#337; k√∂rnyezeten t√∫l a lehet&#337; legjobb k√∂rnyezet fel√°ll√≠t√°s√°ra t√∂rekszenek.</p></div><div class="sect3" title="2.3.6.2. Megbesz√©l√©sek"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1065"></a>2.3.6.2. Megbesz√©l√©sek</h4></div></div></div><p>Sprint Planning Meeting (futamtervez&#337; megbesz√©l√©s): Ezen a tal√°lkoz√≥n kell megbesz√©lni, hogy ki mennyi munk√°t tud elv√°llalni, majd ennek tudat√°ban d√∂nti el a csapat, hogy mely sztorikat v√°llalja be a k√∂vetkez&#337; sprintre. Emellett a m√°sik l√©nyeges dolog, hogy a csapat a Product Owner-rel megbesz√©li, majd teljes m√©rt√©kben meg√©rti, hogy a vev&#337; mit szeretne az adott sztorit√≥l, √≠gy elker√ºlhet&#337;ek az esetleges f√©lre√©rt√©sekb&#337;l ad√≥d√≥ probl√©m√°k. Ha volt Backlog Grooming, akkor nem tart olyan sok√°ig a Planning, ugyanis a csapat ismeri a Backlog-ot, azon nem sz√ºks√©ges finom√≠tani, hacsak a megrendel&#337;t&#337;l nem √©rkezik ilyen ig√©ny. A harmadik dolog, amit meg kell vizsg√°lni, hogy a csapat hogyan teljes√≠tett az el&#337;z&#337; sprintben, vagyis t√∫lv√°llalta-e mag√°t vagy sem. Ha t√∫l sok sztorit v√°llaltak el, akkor le kell vonni a k√∂vetkeztet√©st, √©s a k√∂vetkez&#337; sprintre kevesebbet v√°llalni. Ez a probl√©ma legink√°bb az √∫j, kev√©ss√© √∂sszeszokott csapatokra jellemz&#337;, ahol m√©g nem tudni, hogy mennyi munk√°t b√≠r elv√©gezni a csapat. Ellenkez&#337; esetben, ha alulv√°llalta mag√°t egy csapat, akkor √©rtelemszer&#369;en t√∂bbet v√°llaljon, illetve, ha ide√°lis volt az el&#337;z&#337; sprint, akkor hasonl√≥ mennyis√©g a javasolt.</p><p>Backlog Grooming/Backlog Refinement: A Product Backlog finom√≠t√°sa a Teammel egy√ºtt, el&#337;fordulhat p√©ld√°ul, hogy egy taszk t√∫l nagy, √≠gy story lesz bel&#337;le, √©s ut√°na taszkokra bontva lesz feldolgozva. Ha elmarad, akkor a Sprint Planning hossz√∫ra ny√∫lhat, valamint abban is nagy seg√≠ts√©g, hogy a csapat t√∂k√©letesen meg√©rtse, hogy mit szeretne a megrendel&#337;.</p><p>Daily Meeting/Daily Scrum: A sprint ideje alatt minden nap kell tartani egy r√∂vid megbesz√©l√©st, ami maximum 15 perc, √©s egy el&#337;re megbesz√©lt id&#337;pontban, a csapattagok √©s a Scrum Master jelenl√©t√©ben t√∂rt√©nik (m√°sok is ott lehetnek, de nem sz√≥lhatnak bele). √©rdekess√©g, hogy nem szabad le√ºlni, mindenki √°ll, ezzel is jelezve, hogy ez egy r√∂vid tal√°lkoz√≥. H√°rom k√©rd√©sre kell v√°laszolnia a csapat tagjainak, ezek a k√∂vetkez&#337;ek:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Mit csin√°lt√°l a tegnapi megbesz√©l√©s √≥ta?</p></li><li class="listitem"><p>Mit fogsz csin√°lni a k√∂vetkez&#337; megbesz√©l√©sig?</p></li><li class="listitem"><p>Milyen akad√°lyokba √ºtk√∂zt√©l az adott feladat megold√°sa sor√°n?</p></li></ol></div><p>Sprint Review Meeting (Futam √°ttekint√©s): Minden sprint v√©g√©n √∂ssze√ºlnek a szerepl&#337;k, √©s megn√©zik, hogy melyek azok a sztorik, amelyeket siker√ºlt elk√©sz√≠teni, illetve az megfelel-e a k√∂vetelm√©nyeknek. Ekkor a sztori √°llapot√°t k√©szre √°ll√≠tj√°k. Fontos, hogy egy sztori csak akkor ker√ºlhet ebbe az √°llapotba, ha minden taszkja elk√©sz√ºlt, √©s a Review-on elfogadt√°k. Ezen a megrendel&#337; is jelen van.</p><p>Sprint Retrospective (Visszatekint√©s): Ez az egyik legfontosabb meeting. A Scrum egyik legfontosabb funkci√≥ja, hogy felsz√≠nre hozza azokat a probl√©m√°kat, amelyek h√°tr√°ltatj√°k a fejleszt&#337;ket a feladatmegold√°sban, √≠gy ha ezeket az akad√°lyokat megoldjuk, a csapat jobban tud majd alkalmazkodni a k√∂vetkez&#337; sprint alatt a feladathoz. Probl√©m√°k a Daily Meetingen is el&#337;ker√ºlnek, de ott ink√°bb a szem√©lyeket √©rint&#337; k√©rd√©sek vannak napirenden, m√≠g itt a csapatmunka tov√°bbfejleszt√©se az els&#337;dleges.</p></div><div class="sect3" title="2.3.6.3. Term√©kek"><div class="titlepage"><div><div><h4 class="title"><a name="d0e1088"></a>2.3.6.3. Term√©kek</h4></div></div></div><p>Product Backlog (term√©k teend&#337; lista): Ez az a dokumentum, ahol a Product Owner elhelyezi azokat az elemeket, m√°s n√©ven sztorikat, amelyeket el kell k√©sz√≠teni. Ez egyfajta k√≠v√°ns√°glista. A Product Owner minden sztorihoz priorit√°st, fontoss√°gi sorrendet rendel, √≠gy tudja szab√°lyozni, hogy melyeket kell els&#337;sorban elk√©sz√≠teni, √≠gy a Sprint Planning sor√°n a csapattagok l√°thatj√°k, hogy ami a Backlog-ban legfel√ºl van, azt szeretn√© a vev&#337; leghamarabb k√©szen l√°tni, annak van a legnagyobb √ºzleti √©rt√©ke. Emellett a csapatok s√∫lyozz√°k az elemeket aszerint, hogy melynek az elk√©sz√≠t√©s√©hez kell a kevesebb munka, √≠gy azonos priorit√°s mellett a kevesebb munk√°t ig√©nyl&#337; elemnek nagyobb a befektet√©s megt√©r√ºl√©se (Return of Investment, ROI). Az √ºzleti √©rt√©k meghat√°roz√°sa a Product Owner, a munka megbecsl√©se a csapat feladata. A kett&#337; h√°nyadosa a ROI.</p><p>Sprint Backlog (futam teend&#337; lista): Ebben a dokumentumban az aktu√°lis sprintre bev√°llalt munk√°k, storyk vannak felsorolva, ezeket kell adott id&#337;n bel√ºl a csapatnak megval√≥s√≠tania. A sztorik tov√°bb vannak bontva taszkokra, √©s ezeket a taszkokat v√°llalj√°k el a tagok a Daily Meeting sor√°n. Ez a feldarabol√°sa a feladatoknak a feladat min√©l jobb meg√©rt√©s√©t seg√≠ti.</p><p>Burn down chart (Napi Eredm√©ny Kimutat√°s): Ez egy diagram, amely seg√≠t megmutatni, hogy az ide√°lis munkatemp√≥hoz k√©pest hogyan halad a csapat az aktu√°lis sprinten bel√ºl. K√∂nnyen leolvashat√≥ r√≥la, hogy a csapat √©ppen elakadt-e egy ponton, ak√°r arra is lehet k√∂vetkeztetni, hogy ilyen iramban k√©sz lesz-e minden a sprint v√©g√©re. Vagy √©ppen ellenkez&#337;leg, siker√ºlt felgyors√≠tani az iramot, √©s id&#337;ben, vagy ak√°r kicsit hamarabb is k√©sz lehet a bev√°llalt munka.</p></div></div><div class="sect2" title="2.3.7. Extr√©m programoz√°s"><div class="titlepage"><div><div><h3 class="title"><a name="d0e1097"></a>2.3.7. 
      
               <a name="_Toc285293667"></a>Extr√©m programoz√°s</h3></div></div></div><p>Az extr√©m programoz√°s (angolul: Extreme Programming, vagy r√∂viden: XP) egy agilis m√≥dszertan. A nev√©ben az extr√©m sz√≥ onnan j√∂n, hogy az eddigi m√≥dszertanokb√≥l √°tveszi a j√≥l bev√°lt technik√°kat √©s azokat nem csak j√≥l, hanem extr√©m j√≥l alkalmazza, minden m√°st feleslegesnek tekint. Gyakran √∂sszekeverik a &#8222;programozzunk √∂sszees√©sig&#8221; m√≥dszerrel, amivel egy-k√©t 24 √≥r√°s vagy ak√°r 48 √≥r√°s programoz√≥ versenyen tal√°lkozhatunk.</p><p>Az extr√©m programoz√°s 4 tev√©kenys√©get √≠r el&#337;. Ezek a k√∂vetkez&#337;k:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>K√≥dol√°s: A forr√°sk√≥d a projekt legfontosabb term√©ke, ez√©rt a k√≥dol√°sra kell a hangs√∫lyt helyezni. Igaz√°n k√≥dol√°s k√∂zben j√∂nnek ki a feladat neh√©zs√©gei, hi√°ba gondoltuk azt √°t el&#337;tte. A k√≥d a legalkalmasabb a k√©t programoz√≥ k√∂z√∂tti kommunik√°ci√≥ra, mivel azt nem lehet k√©tf√©lek√©ppen √©rteni. A k√≥d alkalmas a programoz√≥ gondolatainak kifejez√©s√©re.</p></li><li class="listitem"><p>Tesztel√©s: Addig nem lehet√ºnk benne biztosak, hogy egy funkci√≥ m&#369;k√∂dik, am√≠g nem tesztelt√ºk. Az extr√©m felfog√°s szerint kev√©s tesztel√©s kev√©s hib√°t tal√°l, extr√©m sok tesztel√©s megtal√°lja mind. A tesztel√©s j√°tssza a dokument√°ci√≥ szerep√©t. Nem dokument√°ljuk a met√≥dusokat, hanem unit-teszteket fejleszt√ºnk hozz√°. Nem k√©sz√≠t√ºnk k√∂vetelm√©ny specifik√°ci√≥t, hanem √°tv√©teli teszteseteket fejleszt√ºnk a meg√©rtett k√∂vetelm√©nyekb&#337;l.</p></li><li class="listitem"><p>Odafigyel√©s: A fejleszt&#337;knek oda kell figyelni√ºk a megrendel&#337;kre, meg kell √©rteni√ºk az ig√©nyeiket. El kell magyar√°zni nekik, hogy hogyan lehet technikailag kivitelezni ezeket az ig√©nyeket, √©s ha egy ig√©ny kivitelezhetetlen, ezt meg kell √©rtetni a megrendel&#337;vel.</p></li><li class="listitem"><p>Tervez√©s: Tervez√©s n√©lk√ºl nem lehet szoftvert fejleszteni, mert az ad- hoc megold√°sok √°tl√°thatatlan strukt√∫r√°hoz vezetnek. Mivel fel kell k√©sz√ºlni az ig√©nyek v√°ltoz√°s√°ra, ez√©rt √∫gy kell megtervezni a szoftvert, hogy egyes komponensei amennyire csak lehet f√ºggetlenek legyenek a t√∂bbit&#337;l. Ez√©rt √©rdemes pl. objektum orient√°lt tervez√©si alapelveket haszn√°lni.</p></li></ol></div><p>N√©h√°ny extr√©m programoz√°sra jellemz&#337; technika:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>P√°ros programoz√°s (pair programming): K√©t programoz√≥ √≠r egy k√≥dot, pontosabban az egyik √≠rja, a m√°sik figyeli. Ha hib√°t l√°t vagy nem √©rti, akkor azonnal sz√≥l. A k√©t programoz√≥ folyamatosan megbesz√©lik hogyan √©rdemes megoldani az adott probl√©m√°t.</p></li><li class="listitem"><p>Teszt vez√©relt fejleszt√©s (test driven development): M√°r a met√≥dus elk√©sz√≠t√©se el&#337;tt meg√≠rjuk a hozz√° tartoz√≥ unit-teszteket. Ezt n√©ha h√≠vj√°k el&#337;sz√∂r a teszt (test-first) megk√∂zel√≠t√©snek is.</p></li><li class="listitem"><p>Forr√°sk√≥d √°tn√©z√©s (code review): Az elk√©sz√ºlt nagyobb modulokat, pl. oszt√°lyokat, egy vezet&#337; fejleszt&#337; √°tn√©zi, hogy van-e benne hiba, nem √©rthet&#337;, nem dokument√°lt r√©sz. A modul fejleszt&#337;i elmagyar√°zz√°k mit √©s mi√©rt csin√°ltak. A vezet&#337; fejleszt&#337; elmondja, hogyan lehet ezt jobban, szebben csin√°lni.</p></li><li class="listitem"><p>Folyamatos integr√°ci√≥ (continuous integration): A nap (vagy a h√©t) v√©g√©n, a verzi√≥k√∂vet&#337; rendszerbe beker√ºlt k√≥dokat integr√°ci√≥s teszt al√° vetj√ºk, hogy kider√ºlj√∂n, hogy azok k√©pesek-e egy√ºttm&#369;k√∂dni. √≠gy nagyon kor√°n kisz&#369;rhet&#337; a programoz√≥k k√∂zti f√©lre√©rt√©s.</p></li><li class="listitem"><p>K√≥dsz√©p√≠t√©s (refactoring): A m√°r letesztelt, m&#369;k√∂d&#337; k√≥dot lehet sz√©p√≠teni, ami esetleg lass√∫, rugalmatlan, vagy egyszer&#369;en csak cs√∫nya. A k√≥dsz√©p√≠t√©s el&#337;felt√©tele, hogy legyen sok unit-teszt. A sz√©p√≠t√©s sor√°n nem szabad megv√°ltoztatni a k√≥d funkcionalit√°s√°t, de a szerkezet, pl. egy met√≥dus t√∂rzse, szabadon v√°ltoztathat√≥. A sz√©p√≠t√©s ut√°n minden unit-tesztet le kell futtatni, nem csak a megv√°ltozott k√≥dhoz tartoz√≥kat, hogy l√°ssuk, a v√°ltoz√°sok okoztak-e hib√°t.</p></li></ol></div><p>
      
               <img src="images/kep8.png">
   
            </p><p>Az extr√©m programoz√°s akkor m&#369;k√∂dik j√≥l, ha a megrendel&#337; biztos√≠tani tud egy munkat√°rsat, aki √°tl√°tja a megrendel&#337; folyamatait, tudja, mire van sz√ºks√©g. Ha a v√°ltoz√≥, vagy a menet k√∂zben kider√≠tett k√∂vetelm√©nyek miatt gyakran √°t kell √≠rni m√°r elk√©sz√ºlt r√©szeket, akkor az extr√©m programoz√°s nagyon rossz v√°laszt√°s. Kezd&#337; programoz√≥k eset√©n az extr√©m programoz√°s nem alkalmazhat√≥, mert nincs el√©g tapasztalatuk az extr√©m m√≥dszerek alkalmaz√°s√°hoz.</p><p>Az extr√©m programoz√°s legnagyobb er√©nye, hogy olyan fejleszt√©si m√≥dszereket hozott a felsz√≠nre, amik magas min&#337;s√©get biztos√≠tanak. Ezek, mint pl. a p√°ros programoz√°s, nagyon n√©pszer&#369;ek lettek.</p><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch02s02.html">El&#337;z&#337;</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch02.html">Fel</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch03.html">K√∂vetkez&#337;</a></td></tr><tr><td width="40%" align="left" valign="top">2.2. 
      
            A szoftver √©letciklusa&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Tartalom</a></td><td width="40%" align="right" valign="top">&nbsp;3. fejezet - Statikus tesztel√©si technik√°k</td></tr></table></div></body></html>