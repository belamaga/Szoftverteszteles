<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>4.4. Strukt√∫ra alap√∫ technik√°k</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Szoftvertesztel√©s"><link rel="up" href="ch04.html" title="4. fejezet - Teszt tervez√©si technik√°k"><link rel="prev" href="ch04s03.html" title="4.3. Specifik√°ci√≥ alap√∫ technik√°k"><link rel="next" href="ch04s05.html" title="4.5. Gyakorlat alap√∫ technik√°k"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4.4. 
      
            Strukt√∫ra alap√∫ technik√°k</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch04s03.html">El&#337;z&#337;</a>&nbsp;</td><th width="60%" align="center">4. fejezet - Teszt tervez√©si technik√°k</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch04s05.html">K√∂vetkez&#337;</a></td></tr></table><hr></div><div class="sect1" title="4.4. Strukt√∫ra alap√∫ technik√°k"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e2453"></a>4.4. 
      
            <a name="_Toc291171726"></a>Strukt√∫ra alap√∫ technik√°k</h2></div></div></div><p>Ezeknek a m√≥dszereknek az alapja az a tapasztalat, hogy a programoz√°si hib√°k gyakran a vez√©rl√©si szerkezeteket √©rintik. A tesztel√©s c√©lja teh√°t a k√≥d strukt√∫r√°j√°nak a felder√≠t√©se √©s helyess√©g√©nek ellen&#337;rz√©se, ez√©rt a tesztesetek gener√°l√°sa a forr√°sk√≥d elemz√©se alapj√°n t√∂rt√©nik.</p><p>Ebben a szeml√©letben a tesztesetek megtervez√©se sor√°n az a c√©l, hogy a vizsg√°lt k√≥d minden √°g√°t v√©grehajtva vizsg√°ljuk annak m&#369;k√∂d√©s√©t. Mivel egy bonyolult k√≥d v√©grehajt√°si √∫tjainak sz√°ma nagyon magas lehet, √°ltal√°ban nem t√∫l nagy egys√©gek k√©pezik a tesztel√©s t√°rgy√°t.</p><p>A k√≥dbej√°r√°s alapj√°t a k√≥d matematikai modellje, a vez√©rl√©si folyamat gr√°f (control-flow graph, CFG) k√©pezi.</p><p>A vez√©rl√©si folyamat gr√°f egy olyan ir√°ny√≠tott gr√°f, amelyben a csom√≥pontok a program utas√≠t√°sainak felelnek meg, az ir√°ny√≠tott √©lek pedig a v√©grehajt√°suk sorrendj√©t jel√∂lik ki. Egy d√∂nt√©si utas√≠t√°snak megfelel&#337; csom√≥pontb√≥l t√∂bb √©l indul ki, a vez√©rl√©si √°gak √∂sszekapcsol√≥d√°si pontj√°ban elhelyezked&#337; utas√≠t√°shoz pedig t√∂bb √©l fut be. A ciklust visszafel√© ir√°nyul√≥ √©l reprezent√°lja.</p><p>A vez√©rl√©si folyamat gr√°f a forr√°sk√≥db√≥l automatikusan el&#337;√°ll√≠that√≥, erre megfelel&#337; seg√©deszk√∂z√∂k √°llnak rendelkez√©sre. A folyamat gr√°f elemz√©s√©re, k√ºl√∂nb√∂z&#337; jellemz&#337;inek meghat√°roz√°s√°ra pedig a matematika sz√°mos kidolgozott gr√°felm√©leti algoritmust biztos√≠t.</p><p>A tesztel√©s hat√©konys√°g√°nak m√©r√©s√©re m√©r&#337;sz√°mokat haszn√°lhatunk. A m√©r&#337;sz√°mok meghat√°roz√°s√°ra szint√©n rendelkez√©sre √°llnak a megfelel&#337; algoritmusok √©s az azokat v√©grehajtani k√©pes eszk√∂z√∂k.</p><p></p><div class="sect2" title="4.4.1. A strukt√∫ra alap√∫ technik√°k alkalmaz√°si ter√ºletei"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2471"></a>4.4.1. 
      
               <a name="_Toc291171727"></a>A strukt√∫ra alap√∫ technik√°k alkalmaz√°si ter√ºletei</h3></div></div></div><p>Vez√©rl√©s intenz√≠v alkalmaz√°sok</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Ebben a kateg√≥ri√°ban val√≥sz√≠n&#369;leg igaz, hogy a hib√°k a sok esetben a vez√©rl√©si szerkezeteket √©rintik. Algoritmus hib√°kat is kimutathat.</p></li></ol></div><p>Tervez√©si hib√°k felder√≠t√©se</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Els&#337;sorban logikai hib√°k (pl. el√©rhetetlen k√≥dr√©szek)</p></li></ol></div><p>Szabv√°nyok el&#337;√≠r√°sai</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Mivel m√©r&#337;sz√°mokkal min&#337;s√≠thet&#337;, sok szabv√°ny el&#337;√≠rja valamilyen struktur√°lis technika haszn√°lat√°t.</p></li></ol></div></div><div class="sect2" title="4.4.2. A vez√©rl√©si folyamat gr√°f"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2494"></a>4.4.2. 
      
               <a name="_Toc291171728"></a>A vez√©rl√©si folyamat gr√°f</h3></div></div></div><p>A vez√©rl√©si szerkezetet a vez√©rl√©si folyamat gr√°f modellezi, egy program v√©grehajt√°si eset pedig egy √∫t bej√°r√°sa ebben a gr√°fban. Ez√©rt fel√ºletesen mondhatn√°nk, hogy a teljes tesztel√©s valamennyi √∫t bej√°r√°s√°t jelenti.</p><p>Mivel azonban a felt√©telek nem mindig f√ºggetlenek egym√°st√≥l, a bej√°rhat√≥ utak sz√°ma √°ltal√°ban kevesebb, mint az √∂sszes √∫t.</p><p>A ciklomatikus komplexit√°s (CK) a vez√©rl√©si gr√°fban megtal√°lhat√≥ f√ºggetlen utak maxim√°lis sz√°ma. K√©t √∫t f√ºggetlen, ha mindkett&#337;ben l√©tezik olyan pont vagy √©l, amelyik nem eleme a m√°sik √∫tnak.</p><p>A ciklomatikus komplexit√°s √©rt√©ke arra jellemz&#337;, hogy a program vez√©rl√©si szempontb√≥l mennyire bonyolult.</p><p>√°ltal√°nos tesztel√©si c√©l, hogy a teszthalmaz fedje le a f√ºggetlen utak egy maxim√°lis (tov√°bbi f√ºggetlen utakkal m√°r nem b&#337;v√≠thet&#337;) halmaz√°t. Ennek a c√©lnak a megval√≥s√≠t√°s√°t az al√°bbi probl√©m√°k nehez√≠thetik:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Az ilyen utak halmaza nem egyedi, teh√°t ugyanahhoz a k√≥dhoz ak√°r t√∂bb ilyen halmazt is lehet rendelni, ami t√∂bb teszteset halmazt is jelenthet.</p></li><li class="listitem"><p>Mivel a ciklomatikus komplexit√°s a f√ºggetlen utak sz√°m√°nak fels&#337; korl√°tja, egyes halmazok sz√°moss√°ga lehet kisebb, mint a ciklometrikus komplexit√°s.</p></li></ol></div></div><div class="sect2" title="4.4.3. A struktur√°lis tesztgener√°l√°s l√©p√©sei"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2516"></a>4.4.3. 
      
               <a name="_Toc291171729"></a>A struktur√°lis tesztgener√°l√°s l√©p√©sei</h3></div></div></div><p>A teszt gener√°l√°s folyamata l√©nyeg√©ben le√≠rhat√≥ az al√°bbi l√©p√©sekkel.</p><p>Vez√©rl√©si gr√°f gener√°l√°sa</p><p>Ez automatikusan v√©grehajthat√≥ a k√≥d elemz√©s√©vel.</p><p>CK (ciklomatikus komplexit√°s) sz√°m√≠t√°sa</p><p>L√©tezik r√° algoritmus, √©s a k√≥d elemz&#337; eszk√∂z√∂k k√©pesek ezt az √©rt√©ket meghat√°rozni.</p><p>F√ºggetlen utak maxim√°lis (CK db utat tartalmaz√≥) halmaz√°nak gener√°l√°sa</p><p>Ebben a l√©p√©sben m√°r ad√≥dnak probl√©m√°k. Ha vez√©rl√©si gr√°f k√∂rt tartalmaz (m√°rpedig tartalmaz, mert el√©g neh√©z √©rtelmes k√≥dot elk√©pzelni ciklus n√©lk√ºl), az elvben v√©gtelen sz√°m√∫ √∫t gener√°l√°s√°t tenn√© lehet&#337;v√©. Ne felejts√ºk el, hogy a vez√©rl√©si gr√°f nem tartalmaz fut√°s k√∂zbeni √©rt√©keket, √≠gy egy ciklus menetsz√°ma (ami a val√≥s√°gban term√©szetesen v√©ges) a gr√°fb√≥l nem √°llap√≠that√≥ meg. Ez a probl√©ma kezelhet&#337;, de a gener√°land√≥ utak sz√°m√°nak n√∂veked√©s√©t jelenti. K√ºl√∂n√∂sen igaz ez az egym√°sba √°gyazott ciklusok eset√©n. A strukt√∫ra alap√∫ tesztel√©si technik√°k legnagyobb kih√≠v√°s√°t √©ppen a ciklusok kezel√©se jelenti.</p><p>Bemenetek gener√°l√°sa a f√ºggetlen utak bej√°r√°s√°hoz</p><p>Ebben a l√©p√©sben az okozhat probl√©m√°t, hogy egy adott √∫thoz nem felt√©tlen√ºl gener√°lhat√≥ olyan bemeneti kombin√°ci√≥, amely annak a bej√°r√°s√°t eredm√©nyezn√©. Ez persze nem jelenti felt√©tlen√ºl azt, hogy az adott √∫t elemeit k√©pez&#337; utas√≠t√°sok el√©rhetetlenek, csak azt, hogy egy m√°sik √∫t r√©szek√©nt hajt√≥dhatnak v√©gre.</p><p>A tesztel√©s alaposs√°g√°nak ellen&#337;rz√©se k√≥d lefedetts√©gi m√©r&#337;sz√°mokkal</p><p>Az id&#337;k sor√°n sz√°mos ilyen m√©r&#337;sz√°mot dolgoztak ki, √©s megoldott ezen m√©r&#337;sz√°mok automatikus sz√°m√≠t√°sa is. A m√©r&#337;sz√°mok √°ltal√°ban 0 √©s 1 k√∂z√© es&#337; √©rt√©kek. Azt mondhatn√°nk teh√°t, hogy a tesztel√©s akkor teljes, ha egy ilyen m√©r&#337;sz√°m √©rt√©ke 1 (teljes lefedetts√©g), azonban:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>A teljes lefedetts√©g sokszor csak irre√°lisan nagy teszteset halmazzal √©rhet&#337; el, ez√©rt ink√°bb annak csak min√©l jobb megk√∂zel√≠t√©s√©re t√∂rekedhet√ºnk.</p></li><li class="listitem"><p>A 100%-os lefedetts√©g sem jelenti azt, hogy minden hib√°t megtal√°ltunk. (Erre p√©ld√°kat az egyes m√©r&#337;sz√°mok ismertet√©s√©n√©l mutatunk.)</p></li><li class="listitem"><p>Mivel a k√ºl√∂nb√∂z&#337; lefedetts√©gi m√©r&#337;sz√°mok m√°s √©s m√°s szempontb√≥l √©rt√©kelik a tesztel√©s alaposs√°g√°t, c√©lszer&#369; t√∂bbet is haszn√°lni.</p></li></ol></div><p>A lefedetts√©g elemz√©s (coverage analysis) a m√©rt√©ksz√°mok tesztel√©s sor√°n t√∂rt√©n&#337; haszn√°lat√°nak elm√©lete. A gyakorlat ugyanis azt mutatja, hogy a tesztesetek futtat√°si sorendj√©nek &#8222;√ºgyes&#8221; megv√°laszt√°s√°val eleinte a felder√≠tett hib√°k sz√°m√°nak gyors n√∂veked√©s√©t lehet el√©rni, m√©g viszonylag alacsony lefedetts√©g eset√©n is. A teljes lefedetts√©ghez val√≥ k√∂zel√≠t√©s sor√°n a k√©s&#337;bbiekben felt√°rt hib√°t sz√°ma fokozatosan cs√∂kken. K√ºl√∂nb√∂z&#337; strat√©gi√°kkal teh√°t jelent&#337;s k√∂lts√©geket lehet megtakar√≠tani.</p><p>Itt h√≠vn√°m fel arra a figyelmet, hogy a k√≥d lefedetts√©gi mutat√≥ nem azonos a hiba lefedetts√©ggel (amit nem is tudunk sz√°m√≠tani, hiszen ahhoz ismerni kellene a programban lev&#337; hib√°k sz√°m√°t). A k√≥d lefedetts√©g a tesztel√©s alaposs√°g√°t m√©ri, a hiba lefedetts√©g az eredm√©nyess√©g√©t. A tapasztalatok alapj√°n azonban abban b√≠zhatunk, hogy az alapos tesztel√©s az eredm√©nyess√©get is n√∂veli.</p></div><div class="sect2" title="4.4.4. Tesztmin&#337;s√©gi m√©r&#337;sz√°mok"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2557"></a>4.4.4. 
      
               <a name="_Toc291171730"></a>Tesztmin&#337;s√©gi m√©r&#337;sz√°mok</h3></div></div></div><p>Ebben az alpontban az al√°bbi, gyakrabban haszn√°lt k√≥d lefedetts√©gi m√©r&#337;sz√°mok sz√°m√≠t√°si m√≥djait √©s jelent√©s√©t tekintj√ºk √°t</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>utas√≠t√°s lefedetts√©g,</p></li><li class="listitem"><p>√°g lefedetts√©g (vagy d√∂nt√©s lefedetts√©g),</p></li><li class="listitem"><p>√∫t lefedetts√©g.</p></li></ol></div><div class="sect3" title="4.4.4.1. Utas√≠t√°s lefedetts√©g"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2574"></a>4.4.4.1. 
      
                  <a name="_Toc291171731"></a>Utas√≠t√°s lefedetts√©g</h4></div></div></div><p>Sz√°m√≠t√°si m√≥dja:</p><p>S(c) = s/S</p><p>ahol s a tesztel√©s sor√°n legal√°bb egyszer v√©grehajtott, S pedig a program √∂sszes utas√≠t√°sainak a sz√°ma</p><p>A 100% m√©g nem biztos√≠t√©k arra, hogy a teljes tesztel√©s minden hib√°t megtal√°l.</p><p>Egyszer&#369; p√©lda a fenti probl√©m√°ra (hib√°s k√≥dr√©szlet):</p><pre class="programlisting">
   int a=5 ;
   x= &#8230;;
   if (x&gt;0) a = 10;
   a = 20;
         </pre><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Az utas√≠t√°s lefedetts√©g teszt 100%, mert minden sorra r√°ker√ºl a vez√©rl√©s.</p></li><li class="listitem"><p>Ha nem volt olyan teszt, amely sor√°n a felt√©tel igaz √©rt√©ket vesz fel, nem der√ºl ki a hiba.</p></li></ol></div></div><div class="sect3" title="4.4.4.2. √°g lefedetts√©g (d√∂nt√©s lefedetts√©g)"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2598"></a>4.4.4.2. 
      
                  <a name="__RefHeading__15259_1902038280"></a>
      
                  <a name="_Toc291171732"></a>√°g lefedetts√©g (d√∂nt√©s lefedetts√©g)</h4></div></div></div><p>Sz√°m√≠t√°si m√≥dja:</p><p>D(c) = d/D</p><p>ahol d az el√°gaz√°si utas√≠t√°sokban szerepl&#337; felt√©telek kimeneteinek tesztel√©s sor√°n bek√∂vetkezett √©rt√©keinek sz√°ma, D pedig a program √∂sszes el√°gaz√°s utas√≠t√°saiban szerepl&#337; felt√©teleinek lehets√©ges sz√°ma.</p><p>A d√∂nt√©s lefedetts√©g teh√°t akkor teljes, ha a programban szerepl&#337; √∂sszes d√∂nt√©s minden lehets√©ges kimenete el&#337;fordult a tesztel√©s sor√°n. </p><p>A 100%-os lefedetts√©g ugyan alaposabb tesztel√©st eredm√©nyez, mint az utas√≠t√°s lefedetts√©ge, de itt is van ellenp√©lda:</p><pre class="programlisting">
  if (felt1 &amp;&amp; (felt2 || fuggveny() ) ) 
  &nbsp; &nbsp; &nbsp; &nbsp; u1;
   else
   &nbsp; &nbsp; &nbsp; &nbsp; u2;
</pre><p>Ahol felt1 √©s felt2 logikai kifejez√©sek</p><p>A teljes lefedetts√©ghez k√©t teszteset sz√ºks√©ges, hiszen egy felt√©telnek k√©t lehets√©ges kimente van. Ez a k√©t teszteset lehet p√©ld√°ul:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>felt1 √©s felt2 igaz &#8211; ekkor az el√°gaz√°s felt√©tele igaz,</p></li><li class="listitem"><p>felt1 hamis, - ekkor az el√°gaz√°s felt√©tele hamis.</p></li></ol></div><p>Ebben a k√©t tesztesetben egyszer sem volt sz√ºks√©g a harmadik operandus ki√©rt√©kel√©s√©re, teh√°t a f√ºggv√©ny nem h√≠v√≥dik meg. Ha abban van hiba, az felder√≠tetlen marad.</p></div><div class="sect3" title="4.4.4.3. ⁄t lefedetts√©g"><div class="titlepage"><div><div><h4 class="title"><a name="d0e2630"></a>4.4.4.3. 
      
                  <a name="_Toc291171733"></a>⁄t lefedetts√©g</h4></div></div></div><p>Sz√°m√≠t√°si m√≥dja:</p><p>P(c) = p/P</p><p>ahol p a tesztel√©s sor√°n bej√°rt utak sz√°ma, P pedig a vez√©rl√©si gr√°f √∂sszes √∫tjainak a sz√°ma</p><p>Teljes √∫t lefedetts√©g teljes utas√≠t√°s √©s √°g lefedetts√©get biztos√≠t.</p><p>Nagyon szigor√∫ m√©r&#337;sz√°m, mert</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Az √∂sszes utak sz√°ma nagyon nagy lehet, ez√©rt a tesztesetek gener√°l√°sa √©s lefuttat√°sa er&#337;forr√°s ig√©nyes.</p></li><li class="listitem"><p>A vez√©rl√©si gr√°fban lehetnek nem bej√°rhat√≥ utak az egym√°st kiz√°r√≥ felt√©telek miatt, teh√°t a teljes lefedetts√©g nem is mindig el√©rhet&#337;.</p></li></ol></div></div></div><div class="sect2" title="4.4.5. A strukt√∫ra alap√∫ tesztek szerepe"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2652"></a>4.4.5. 
      
               <a name="_Toc291171734"></a>A strukt√∫ra alap√∫ tesztek szerepe</h3></div></div></div><p>A fenti r√∂vid bevezet&#337;b&#337;l is l√°tszik, hogy a strukt√∫ra alap√∫ tesztel√©s bonyolult √©s er&#337;forr√°s ig√©nyes feladat. V√©grehajt√°s√°hoz speci√°lisan erre a c√©lra fejlesztett eszk√∂z√∂k kellenek, mert manu√°lis v√©grehajt√°sa a bonyolult algoritmusok √©s a sz√ºks√©ges tesztesetek nagy sz√°ma miatt legfeljebb mintap√©ld√°kon lehets√©ges.</p><p>Bonyolults√°ga ellen√©re sem mell&#337;zhet&#337;k ezek a tesztek a biztons√°g-kritikus rendszerek eset√©n. Az ilyen rendszerekn√©l a program v√°ratlan viselked√©se egy adott helyzetben ak√°r ember√©leteket is vesz√©lyeztethet, vagy jelent&#337;k k√°rokat okozhat. Ha a teljes lefedetts√©get minn√©l jobban megk√∂zel√≠t&#337;, alapos tesztel√©snek vetj√ºk al√° ezeket a rendszereket, a v√°ratlan viselked√©s val√≥sz√≠n&#369;s√©ge az elfogadhat√≥ kock√°zati szint al√° cs√∂kkenthet&#337;.</p><p>A tesztek sor√°n alkalmazott lefedetts√©gi mutat√≥k alkalmazhat√≥k az utas√≠t√°sokn√°l nagyobb absztrakci√≥s szint&#369; strukt√∫r√°kra is. Ilyenkor a vez√©rl√©si folyamat gr√°f elemei lehetnek p√©ld√°ul alrendszerek, modulok, interf√©szek, vagy ak√°r a men√ºstrukr√∫ra elemei. Az integr√°ci√≥s tesztek eset√©n ilyen m√≥don m√≥don m√©rhetj√ºk, hogy a v√©grehajtott teszt k√©szletek a rendszer elemeit mennyire alaposan fedt√©k le.</p><p></p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch04s03.html">El&#337;z&#337;</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch04.html">Fel</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch04s05.html">K√∂vetkez&#337;</a></td></tr><tr><td width="40%" align="left" valign="top">4.3. 
      
            Specifik√°ci√≥ alap√∫ technik√°k&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Tartalom</a></td><td width="40%" align="right" valign="top">&nbsp;4.5. 
      
            Gyakorlat alap√∫ technik√°k</td></tr></table></div></body></html>