<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <title>10.3. Adatb√°zis √∫jratervez√©s folyamata</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="index.html" title="Szoftvertesztel√©s"><link rel="up" href="ch10.html" title="10. fejezet - Adatb√°zisok tesztel√©se"><link rel="prev" href="ch10s02.html" title="10.2. TDD alap√∫ adatb√°zis fejleszt√©s"><link rel="next" href="ch10s04.html" title="10.4. Adatb√°zis tesztel√©si seg√©dprogramok"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">10.3. Adatb√°zis √∫jratervez√©s folyamata</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch10s02.html">El&#337;z&#337;</a>&nbsp;</td><th width="60%" align="center">10. fejezet - Adatb√°zisok tesztel√©se</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch10s04.html">K√∂vetkez&#337;</a></td></tr></table><hr></div><div class="sect1" title="10.3. Adatb√°zis √∫jratervez√©s folyamata"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d0e5725"></a>10.3. Adatb√°zis √∫jratervez√©s folyamata</h2></div></div></div><p>Az adatb√°zis √∫jratervez√©s egyik fontos jellemz&#337;je, hogy az adatb√°zist p√°rhuzamosan t√∂bben, t√∂bb k√ºl√∂nb√∂z&#337; alkalmaz√°s is haszn√°lhatja. Sajnos legt√∂bbsz√∂r 
                nem ismert az adatb√°zist felhaszn√°l√≥ alkalmaz√°sok teljes k√∂re. Ez nagy megk√∂t√∂tts√©get jelent a fejleszt√©s sor√°n, hiszen ekkor nem szabad m√≥dos√≠tani a megl√©v&#337; interface 
                fel√ºletek megjelen√©s√©t. A kor√°bban megl√©v&#337; adatelemek √©s adatb√°zis objektumoknak  meg kell maradniuk. Ebben az esetben a fejleszt√©s csak olyan lehet, amely b&#337;v√≠ti √©s nem sz&#369;kiiti 
                az el√©rhet&#337; funkci√≥k√∂rt, azaz az al√°bbi elemekre vonatkozhat:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>√∫j adatb√°zis objektum hozz√°ad√°sa</p></li><li class="listitem"><p>adatb√°zis m&#369;k√∂d√©si t√°rol√°si param√©terek m√≥dos√≠t√°sa</p></li><li class="listitem"><p>megszor√≠t√°sok t√∂rl√©se</p></li></ul></div><p>Mivel az adatb√°zis egy k√∂z√∂sen haszn√°lt er&#337;forr√°s, melynek tartalma, szerkezete az √©lete alatt jelen&#337;sen megv√°ltozhat, nagyon fontos, hogy ezen j√∂v&#337;beli m√≥dos√≠t√°si ig√©nyekre 
                tekintettel legy√ºnk a tervez√©s sor√°n. Ehhez  min√©l magasabb szinten meg kell val√≥s√≠tani az adatb√°zis el√©r√©s modularit√°s√°t, r√©tegz&#337;d√©s√©t.  Az adatb√°zis kezel√©s vil√°g√°ban az al√°bbi eszk√∂z√∂ket
                lehet haszonnal alkalmazni a f√ºggetlens√©gi szint emel√©s√©re:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>N√©zeti t√°bl√°k (VIEW) alkalmaz√°sa: A n√©zeti t√°bl√°k olyan sz√°rmaztatott t√°bl√°kat jelentenek, melyek m√°s forr√°st√°bl√°kb√≥l √©p√≠tik fel tartalmukat, &#337;k maguk pedig norm√°l 
                    t√°blak√©nt √©rhet&#337;k el a legt√∂bb m&#369;velet sor√°n. A VIEW l√©trehoz√°s parancsa:
</p><pre class="programlisting">
   CREATE VIEW vnev AS SELECT-parancs
</pre><p>                    
                   A  n√©zeti t√°bla teljes m√©rt√©kben azonosan viselkedik a norm√°l t√°bl√°kkal a lek√©rdez√©s eset√©ben:
                   </p><pre class="programlisting">
  SELECT .. FROM vnev WHERE .. ;                       
                   </pre><p>
                        A m√≥dos√≠t√°si parancs eset√©ben m√°r korl√°tozott a hasonl√≥s√°g. A VIEW-ra kiadott  DML parancs csak akkor fog v√©grehajt√≥dni, ha a VIEW adatelemei egy√©rtelm&#369;en visszavezethet&#337;k
                        a forr√°st√°bla adatokra. A VIEW haszn√°lat el&#337;nyei:
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>elrejti a t√©nyleges adatt√°bl√°t</p></li><li class="listitem"><p>f√ºggetlens√©gi szint a kliens √©s az adatb√°zis k√∂z√∂tt</p></li><li class="listitem"><p>sz√°rmaztatott adatokat tartalmazhat.</p></li><li class="listitem"><p>v√©delmi funkci√≥kat val√≥s√≠that meg</p></li></ul></div><p>
                        A VIEW seg√≠ts√©g√©vel elrejthet&#337; az alapstrukt√∫ra m√≥dosul√°sa, hiszen csak a felhaszn√°l√≥ √°ltal haszn√°lt VIEW elemek defin√≠ci√≥j√°t kell m√≥dos√≠tani. 
                    </p></li><li class="listitem"><p>T√°rolt elj√°r√°sok (STORED PRECEDURE) alkalmaz√°sa: A t√°rolt elj√°r√°s hasonl√≥an egy k√∂ztes r√©teget hoz be a felhaszn√°l√≥ √©s az adatb√°zis mag k√∂z√©. A 
                        t√°rolt elj√°r√°s magj√°ban egy procedur√°lis egys√©g rejlik, mely a SQL parancsok mellett vez√©rl√©si elemeket, v√°ltoz√≥ kezel√©st √©s k√ºls&#337; seg√©dprogramokat is megh√≠vhat. A
                        t√°rolt elj√°r√°s f&#337; el&#337;nye a nagyfok√∫ rugalmass√°g, h√°tr√°nya, hogy k√∂r√ºlm√©nyesebb fejleszteni √©s tesztelni. A t√°rolt elj√°r√°s l√©trehozatala a 
</p><pre class="programlisting">
    CREATE PROCEDURE pnev () AS
       t√∂rzs
</pre><p>                        
                paranccsal t√∂rt√©nik. A l√©trehozott elj√°r√°s a kliens API-b&#337;l rendszerint egy 
</p><pre class="programlisting">
     CALL pnev();
</pre><p>                
             utas√≠t√°ssal lehets√©ges.  E m√≥dszer h√°tr√°nya, hogy nem norm√°l t√°blak√©nt jelenik meg, bel√ºl v√©gez m&#369;veleteket. 
             E korl√°t megsz√ºntet√©se a rekordhalmazt visszaad√≥ t√°rolt f√ºggv√©nnyel oldhat√≥ meg. Ezen mechanizmus haszn√°lat√°nak l√©p√©sei az Oracle p√©ld√°ja eset√©n:
             </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Az eredm√©ny rekord szerkezet√©t le√≠r√≥ adatt√≠pus l√©trehozatala:
</p><pre class="programlisting">
  CREATE TYPE rtipus AS OBJECT (..);
</pre><p>                                      
                 
                        </p></li><li class="listitem"><p>A rekordhalmaz szerkezet√©t le√≠r√≥ t√°bla-t√≠pus defini√°l√°sa:</p><pre class="programlisting">
  CREATE TYPE  ttipus AS TABLE OF rtipus;                     
                 </pre><p>
                        </p></li><li class="listitem"><p>
                Az eredm√©nyhalmazt l√©trehoz√≥ t√°rolt f√ºggv√©ny k√≥dol√°sa. Ezen f√ºggv√©ny visszat√©r√©si √©rt√©k t√≠pusa az el&#337;z&#337; l√©p√©sben defini√°lt adatt√≠pus:
</p><pre class="programlisting">
  CREATE FUNCTION fnev  (param√©terek)  RETURN  ttipus IS
      pl_sql blokk;
</pre><p>                
                 
                        </p></li><li class="listitem"><p>A l√©trehozott f√ºggv√©ny  t√°bla-szer&#369;en h√≠vhat√≥ meg, melyhez  a TABLE f√ºggv√©nyt kell alkalmazni:
</p><pre class="programlisting">
   SELECT * FROM TABLE(fnev(...));
</pre><p>                 
                 
                        </p></li></ol></div><p>                        
                    
               </p></li><li class="listitem"><p>Szinonim√°k (SYNONYM) alkalmaz√°sa:  A szinonima  els&#337;dleges szerepe, hogy az adott elnevez√©s&#369; objektumokhoz egy √∫j alias nevet lehessen
                        hozz√°rendelni.  Az √∫j elnevez√©s l√©nyege, hogy 
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>elrejti a forr√°s adatokat</p></li><li class="listitem"><p>elrejti a kliens el&#337;l a forr√°ss√©ma v√°ltoz√°s√°t</p></li></ul></div><p>                        
                    
               </p></li><li class="listitem"><p>Trigger alkalmaz√°sa: A trigger mechanizmus automatikus m&#369;velet v√©grehajt√°st tesz lehet&#337;v√©. Kiv√°lt√≥ja rendszerint egy DML m&#369;velet. A trigger l√©trehoz√°s parancsa:
</p><pre class="programlisting">
    CREATE TRIGGER tnev AFTER | BEFORE INSERT | UPDATE | DELETE 
    ON tabla PL-SQL blokk;
</pre><p>                    
                    A trigger f&#337; szerepe a f√ºggetlens√©gi szint biztos√≠t√°sa eset√©n abban √°ll, hogy az alapt√°bl√°k √©s a felhaszn√°l√≥ √°ltal √©rintett t√°bl√°k k√∂z√∂tti adatmozg√°s automatiz√°lhat√≥. 
                    </p></li><li class="listitem"><p>Saj√°t s√©ma (SCHEMA)  haszn√°lata: A saj√°t s√©ma szerepe, hogy k√ºl√∂n s√©m√°ba tegy√ºk a t√©nyleges alapadatokat √©s a felhaszn√°l√≥ √°ltal √©rintett objektumokat. Ekkor 
                    az √©rintett kapcsolati objektumokon v√©grehajtott v√°ltoz√°sok fel√ºgyelt m√≥don √°tvezet√©sre ker√ºlnek a forr√°s s√©ma objektumaiba. Ez√°ltal ugyan t√∂bblet k√∂lts√©g jelenik meg a v√©grehajt√°sn√°l, 
                    de nagyobb f√ºggetlens√©g √©rhet&#337; el a fejleszt√©sn√©l.</p></li></ul></div><p>
                    Az adatb√°zis √∫jratervez√©s √°ltal√°nos esetben mag√°ba foglalhatja azonban a kor√°bbi s√©maelemek m√≥dos√≠t√°s√°t is. Erre akkor lehet sz√ºks√©g, ha kider√ºl, hogy a kor√°bbi tervez√©si elk√©pzel√©s 
                    nem √°llja meg a hely√©t, korrekci√≥ra van sz√ºks√©g. Ez lehet a tervez&#337; hib√°ja, de lehet a k√∂vetelm√©nyek v√°ltoz√°sa miatti esem√©ny is. ⁄jratervez√©s eset√©n k√ºl√∂n√∂s gonddal kell kezelni a 
                    kor√°bbi funkci√≥k z√∂kken&#337;mentes √°tvitel√©t az √∫j verzi√≥ba. Az adatb√°zis √∫jratervez√©s szok√°sos elemei:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Adatb√°zis √∫jratervez√©si strat√©gia kiv√°laszt√°sa: ezen l√©p√©sben mag√°t az √∫jratervez√©st kell megtervezni. Nem lehet hirtelen felindul√°sb√≥l 
                        l√©nyeges m√≥dos√≠t√°sokat kereszt√ºlvinni az adatb√°zisban.</p></li><li class="listitem"><p>A kor√°bbi adatb√°ziss√©ma kifuttat√°sa: Mint kor√°bban eml√≠tett√ºk, az adatb√°zisokn√°l nem minden adatkezel&#337; alkalmaz√°s logik√°ja ismert pontosan.  
                        Nem lehet azt sem pontosan megbecs√ºlni, milyen hat√°ssal lesz egy adott elem s√©m√°j√°nak megv√°ltoz√°sa az alkalmaz√°sokra. Ezen kifut√°si id&#337; f&#337; jellemz&#337;je, hogy
                        a r√©gi s√©ma elemei fokozatosan mennek √°t egym√°sba, esetleg mindkett&#337; egy√ºtt √©l.  Az √°tmeneti id&#337;szak egy hosszabb id&#337;szak, ak√°r egy-k√©t √©v is is eltarthat. 
                        </p></li><li class="listitem"><p>tesztel√©s az √∫jratervez√©s el&#337;tt: Ezen a k√©s&#337;bbi pontokban megadott tesztel√©snek le kell fednie minden fontosabb elemet, √≠gy bevon√°sra ker√ºl a
                     
                        </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>s√©ma tesztel√©se;</p></li><li class="listitem"><p>alkalmaz√°sok adatkezel√©s√©nek tesztel√©se;</p></li><li class="listitem"><p>adatok √©rt√©kellen&#337;rz√©se, integrit√°si szab√°lyok tesztel√©se;</p></li><li class="listitem"><p>jogosults√°g ellen&#337;rz√©se;</p></li><li class="listitem"><p>hat√©konys√°gi k√∂vetelm√©nyek ellen&#337;rz√©se.</p></li></ul></div><p>                            
                        
                  </p></li><li class="listitem"><p>s√©ma m√≥dos√≠t√°sa: az elv√©gzett m√≥dos√≠t√°sokat c√©lszer&#369; egy verzi√≥ k√∂vet&#337; rendszer hat√°sk√∂r√©ben elv√©gezni, hiszen el&#337;fordulhat, hogy 
                        nem bizonyul sikeresnek a m√≥dos√≠t√°s √©s vissza kell t√©rni a kor√°bbi √°llapotokhoz. Tov√°bbi fontos √°ltal√°nos k√∂vetelm√©ny, hogy a v√°ltoz√°sokat lehet&#337;leg min√©l kisebb egys√©gekben 
                        hajtsuk v√©gre, hiszen a nagyobb m√©ret&#369; feladatokn√°l nagyobb az es√©lye a hib√°z√°snak is.</p></li><li class="listitem"><p>tesztel√©s az √∫jratervez√©s alatt</p></li><li class="listitem"><p>forr√°sadatok √°temel√©se: az √∫j s√©maelemekbe √∫j adatokra van sz√ºks√©g. Az adatok t√∂bb forr√°sb√≥l sz√°rmazhatnak: lehetnek sz√°rmaztatott adatok, melyek a
                         m√°r let√°rolt adatokb√≥l sz√°m√≠t√°ssal √°llnak el&#337;. Illetve lehetnek k√ºls&#337; forr√°sb√≥l √°tvett adatok. Az adatok be√©p√≠t√©s√©t jelent&#337;sen seg√≠tik a bet√∂lt&#337; modulok. Egy ilyen bet√∂lt&#337; 
                        modul a Microsoft Integration Service komponense, mely heterog√©n adatforr√°sokb√≥l √°tvett adatokat is √∂ssze tud integr√°lni.</p></li><li class="listitem"><p>k√ºls&#337; kezel&#337; programok m√≥dos√≠t√°sa: A s√©ma elemek m√≥dos√≠t√°sa miatt m√≥dos√≠t√°sra szorulhatnak a k√ºls&#337; alkalmaz√°sok is. Az √∫j funkci√≥k miatt 
                        megv√°ltoznak az adatb√°zisok el√©r√©si parancsai √©s √°tvett adatszerkezetei is.</p></li><li class="listitem"><p>k√ºls&#337; kezel&#337; programok tesztel√©se</p></li><li class="listitem"><p>regresszi√≥s tesztek futtat√°sa: a regresszi√≥s teszt sikeres lefut√°sa eset√©n mondhatjuk el, hogy siker√ºlt a kor√°bbi funkci√≥kat meg&#337;rizni √©s √°tvenni az √∫j 
                        adatb√°zis s√©m√°ba. A regresszi√≥s tesztek is egy gy&#369;jtem√©nyt alkotnak, mely k√©szlet maga is dinamikusan v√°ltozik. </p></li><li class="listitem"><p>verzi√≥ v√°lt√°s: A sikeres teszt futtat√°sok ut√°n lehet homokoz√≥kb√≥l √°tvinni az adatb√°zist a produkci√≥s v√°ltozatba. Az adatb√°zisok migr√°ci√≥j√°ra t√∂bb √∫t is k√≠n√°lkozik:
                            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>BACKUP √©s RESTORE seg√©dprogramok</p></li><li class="listitem"><p>EXPORT √©s IMPORT seg√©dprogramok</p></li><li class="listitem"><p>SQL script √°llom√°nyok haszn√°lata</p></li></ul></div><p>
                            
                        
                  </p></li></ul></div><p>
                
         </p><div class="sect2" title="10.3.1. S√©ma elemek t√∂rl√©se"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5883"></a>10.3.1. S√©ma  elemek t√∂rl√©se</h3></div></div></div><p>Ha az adatb√°zisban a v√°ltoztat√°s c√©lja kor√°bban l√©tez&#337; adatb√°zis elemek elvet√©se, akkor a m√≥dos√≠t√°st t√∂bb l√©p√©sen kereszt√ºl c√©lszer&#369; v√©gigvinni. Az egyes l√©p√©sek c√©lja, hogy
                        min√©l hamarabb √©szrevegy√ºk az esetleges konfliktusokat √©s m√©g id&#337;ben, a nagyobb l√©pt√©k&#369; m√≥dos√≠t√°s el&#337;tt feloldjuk az ellentmond√°sokat. Az adatelemek t√∂rl√©sekor
                        emiatt az al√°bbi l√©p√©seket c√©lszer&#369; v√©grehajtani:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Seg√©dt√°bla l√©trehozatala az eredeti adatok meg&#337;rz√©s√©re:
</p><pre class="programlisting">
    CREATE TABLE seged (...);
</pre><p>                        
                        
                  </p></li><li class="listitem"><p>Az adatok √°temel√©se a seg√©dt√°bl√°ba:
</p><pre class="programlisting">
    INSRERT INTO seged SELECT * FROM ...;
</pre><p>                        
                        
                  </p></li><li class="listitem"><p>Az √©rintett s√©maelem t√∂rl√©s s√©ma szint&#369; el&#337;k√©sz√≠t√©se. Az objektum t√≠pus√°t√≥l f√ºgg&#337;en k√ºl√∂nb√∂z&#337; s√©ma √°talak√≠t√°sokra lehet sz√ºks√©g. Egy t√°bla
                        t√∂rl√©sekor p√©ld√°ul sorra kell venni az al√°bbi elemeket:
                        </p><table border="0" summary="Simple list" class="simplelist"><tr><td>- rajta √©rtelmezett VIEW-k</td></tr><tr><td>- rajta √©rtelmezett SYNONYM-√°k</td></tr><tr><td>- rajta √©rtelmezett t√°rolt elj√°r√°sok</td></tr><tr><td>- rajta √©rtelmezett TRIGGER-ek</td></tr><tr><td>- oda vonatkoz√≥ hivatkoz√°si megk√∂t√©sek</td></tr></table><p>
                            
                            Ezen objektumokat mind m√≥dos√≠tani vagy t√∂r√∂lni kell, miel&#337;tt a hivatkozott objektumot m√≥dos√≠tan√°nk. </p></li><li class="listitem"><p>Az √©rintett objektum t√∂rl√©se. Az objektum t√∂rl√©se eset√©n a t√∂rl√©s egyes esetekben t√∂bb l√©p√©sben val√≥sulhat meg. Az Oracle rendszer eset√©ben
                        p√©ld√°ul egy mez&#337; t√∂rl√©sekor lehet&#337;s√©g van logikai t√∂rl√©sre √©s fizikai t√∂rl√©sre. A logikai t√∂rl√©s eset√©ben a DBMS csak haszn√°laton k√≠v√ºl helyezi a mez&#337;t, 
                        a m&#369;velet parancsa 
</p><pre class="programlisting">
    ALTER TABLE tabla SET UNUSED mez&#337;;
</pre><p>                        
                            A fizikai t√∂rl√©s eset√©ben t√©nylegesen megsz&#369;nik a kijel√∂lt mez&#337;, az ide vonatkoz√≥ SQL parancs Oracle eset√©ben:
</p><pre class="programlisting">
    ALTER TABLE tabla DROP COLUMN mez&#337;;
</pre><p>                            
                        
                  </p></li></ul></div><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>A m√≥dos√≠t√°s tesztel√©se. A hivatkoz√≥ √©s m√°r m√≥dos√≠tott elemek (VIEW, TRIGGER, PROCEDURE,FOREIGN KEY..) m&#369;k√∂d√©s√©nek ellen&#337;rz√©se.</p></li></ul></div></div><div class="sect2" title="10.3.2. ⁄j s√©maelem felvitele"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5929"></a>10.3.2. ⁄j s√©maelem felvitele</h3></div></div></div><p>A s√©ma b&#337;v√≠t√©skor is sz√ºks√©g van a hivatkoz√≥ objektumok sorra v√©tel√©re, hiszen el&#337;fordulhat, hogy a hivatkoz√≥ objektum nem haszn√°lja ki a 
                    mez&#337;szint&#369; f√ºggetlens√©g adta lehet&#337;s√©geket. M√≠g p√©ld√°ul egy
</p><pre class="programlisting">
    SELECT m1,m2,.. FROM ..
</pre><p>                   
                      alak√∫ lek√©rdez√©s eredm√©nye nem v√°ltozik, ha √∫j mez&#337;t adunk a s√©m√°hoz, addig a
</p><pre class="programlisting">
    SELECT * FROM ..
</pre><p>                   
                    alakban kiadott m&#369;veletn√©l b&#337;v√ºl a visszaadott mez&#337;k k√∂re, teh√°t fel kell k√©sz√ºlni annak fogad√°s√°ra. Ilyenkor az √∫j mez&#337; neve konfliktusba ker√ºlhet a 
                    kliens programokban haszn√°lt v√°ltoz√≥ nevekkel. Ezen √ºtk√∂z√©seket kell ellen&#337;rizni.                   
                    </p><p>Ha sz√°m√≠tott mez&#337;ket hozunk be a s√©m√°ba, akkor annak megval√≥s√≠t√°s√°ra t√∂bb lehet&#337;s√©g is k√≠n√°lkozik:
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Egyes DBMS rendszerek k√∂zvetlen√ºl is t√°mogatj√°k a sz√°m√≠tott mez&#337; adatt√≠pus. Az MS SQL Server eset√©ben az al√°bbi m√≥don hozhat√≥ l√©tre 
                        sz√°rmaztatott mez&#337;:
</p><pre class="programlisting">
  create table proba (a integer, b integer, c as a + b);
  insert into proba values (1,3);
  select * from proba; 
</pre><p>
                            A mint√°ban a C mez&#337; lesz sz√°m√≠tott mez&#337;, itt az adatt√≠pus hely√©n a sz√°rmaztat√°si parancs szerepel a t√°bla defin√≠ci√≥ban. Adatok felvitelekor nem lehet ezen mez&#337;knek 
                            √©rt√©ket adni, de lek√©rdez√©skor ott szerepel a mez&#337; √©rt√©ke.
                        </p></li><li class="listitem"><p>Ha a DBMS nem t√°mogatja a sz√°m√≠tott mez&#337;t k√∂zvetlen√ºl, akkor a TRIGGER mechanizmus alkalmazhat√≥. Ilyenkor a mez&#337;t mint 
                        norm√°l mez&#337;t hozzuk l√©tre √©s a triggert a t√°bla DML m&#369;veleteihez k√∂tj√ºk. A trigger feladata, hogy a t√∂bbi mez&#337; m√≥dosul√°sa eset√©n friss√≠tse a kijel√∂lt 
                        sz√°m√≠tott mez&#337; tartalm√°t. </p></li></ul></div><p>
                        
                    
            </p></div><div class="sect2" title="10.3.3. V√©delmi tesztek"><div class="titlepage"><div><div><h3 class="title"><a name="d0e5953"></a>10.3.3. V√©delmi tesztek</h3></div></div></div><p>Az adatb√°zisban t√°rolt adatok v√©delm√©nek biztos√≠t√°sa is az egyik alapvet&#337; adatb√°zis feladatok k√∂z√© tartozik. Az rel√°ci√≥s adatb√°ziskez&#337;k  egyik jellemz&#337;je, hogy  SQL parancsok 
                        alakj√°ban kapja meg a v√©grehajtand√≥ parancsot. Mivel az SQL nyelv teljes parancsk√©szletet tartalmaz √©s egy sztringben t√∂bb parancs is j√∂het, a nem megfelel&#337; SQL sz√∂veg
                        k√°rokat okozhat. Emiatt igen fontos, hogy az elk√ºld√∂tt sz√∂veg pontosan megfeleljen az elv√°rt alaknak. Ha nem megfelel&#337; az ellen&#337;rz√©s, akkor k√°rt okoz√≥ parancsok 
                        ker√ºlhetnek v√©grehajt√°sra. Ezt a vesz√©lyt√≠pust nevezik  SQL Injection t√°mad√°snak. 
                    </p><p>Az SQL Ijnjection eset√©ben a kliens oldalon bevitt SQL alak olyan parancselemeket is tartalmaz, melyek nem k√≠v√°nt hat√°ssal j√°rnak. Ezt √∫gy √©rik el, hogy a 
                    felhaszn√°l√≥t√≥l kapott √©rt√©k √∫gy t√©r el az elv√°rt alakt√≥l, hogy egy vesz√©lyt okoz√≥ parancsot vagy parancs r√©szletet is mag√°ba foglal. P√©ldak√©nt vegy√ºnk egy egyszer&#369; nyilv√°ntarrt√≥
                    rendszert, ahol a felhaszn√°l√≥t√≥l lek√©rdezz√ºk a keresett √°ru nev√©t. Ehhez a GUI tartalmaz egy anev mez&#337;t. A mez&#337;be bevitt √©rt√©ket egy SQL parancsban adjuk √°t, mint kulcs√©rt√©ket:</p><pre class="programlisting">
   parancs = "SELECT * FROM termekek WHERE nev = '" 
   + anev.text +"'  ";
</pre><p>Ha a felhaszn√°l√≥ az elv√°rt norm√°l azonos√≠t√≥ n√©v helyett egy </p><pre class="programlisting">
   baba'  or   'a'='a'
</pre><p>√©rt√©ket visz fel, akkor az elk√ºld√∂tt parancssor a </p><pre class="programlisting">
   SELECT * FROM termekek WHERE nev = 'baba' or 'a'='a';   
</pre><p>lesz, amely minden term√©ket vissza fog adni. M√©g s√∫lyosabb k√°r √©ri a rendszert, ha a bevitt parancs </p><pre class="programlisting">
    baba' ; delete from termekek where  'a'='a'
</pre><p>alak√∫, hiszen ekkor k√©t egym√°st k√∂vet&#337; parancs ker√ºl a szerver oldalon v√©grehajt√°sra, melyek alakjai</p><pre class="programlisting">
     SELECT * FROM termekek WHERE nev = 'baba';
     DELETE FROM term√©kek WHERE 'a'='a';
</pre><p>A fenti t√°mad√°sok ellen a beolvasott param√©terek alaposabb ellen&#337;rz√©s√©vel illetve a parancsok k√©tf√°zis√∫ v√©grehajt√°s√°val lehet v√©dekezni. </p><p>A v√©delmi tesztek eset√©ben is t√∂bb szinten futhat az ellen&#337;rz√©s. A FirtsTechnologies aj√°nl√°sa alapj√°n az al√°bbi tesztek  ker√ºlnek v√©grehajt√°sra:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>K√ºls&#337;, alkalmaz√°s szint&#369; tesztel√©s (p√©ld√°ul az SQL Injection t√°mad√°s ellen&#337;rz√©se)</p></li><li class="listitem"><p>Adatb√°zis audit: a be√©p√≠tett v√©delmi politika ellen&#337;rz√©se, jogosults√°gi politika  tesztel√©se</p></li><li class="listitem"><p>Adatb√°zis behatol√°s teszt, k√ºl√∂nb√∂z&#337; seg√©deszk√∂z√∂k r√©v√©n kis√©rletek az adatb√°zis adatok el√©r√©s√©re</p></li><li class="listitem"><p>OS szint&#369; audit, az oper√°ci√≥s rendszer fel&#337;li v√©delmi elemek ellen&#337;rz√©se</p></li><li class="listitem"><p>Adatfolyam elemz√©s: a szerver √©s a kliensek k√∂z√∂tti adatfolyam ellen&#337;rz√©se</p></li></ul></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch10s02.html">El&#337;z&#337;</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="ch10.html">Fel</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch10s04.html">K√∂vetkez&#337;</a></td></tr><tr><td width="40%" align="left" valign="top">10.2. TDD alap√∫ adatb√°zis fejleszt√©s&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Tartalom</a></td><td width="40%" align="right" valign="top">&nbsp;10.4. Adatb√°zis tesztel√©si seg√©dprogramok</td></tr></table></div></body></html>